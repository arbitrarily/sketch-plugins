@import 'version.js';
@import 'nibui.js';
@import 'default-colors.js';
@import 'persistence.js';
@import 'bitmapimporter.js';
@import 'menus.cocoascript';
@import 'modals.cocoascript';
@import 'shared-styles-helpers.cocoascript';
@import 'text-styles-helpers.cocoascript';
@import 'require.js';
@import 'process-upload-layer-candidates.cocoascript'
@import 'login.cocoascript'

const util = require('./util');
const $ = require('./collection-helpers');
const coerce = require('./coerce');
const constants = require('../shared/constants');
const archive = require('./archive');
const craftImport = require('./craft-import');
const localImageCache = require('./local-image-cache');
const layerExport = require('./layer-export');
const fonts = require('./fonts');
const typeStyles = require('./type-styles');
const colors = require('./colors');
const dependencyHelpers = require('./dependency-helpers');
const traverseLayerTree = require('./traverse-layer-tree').traverseLayerTree;
const UI = require('./ui');
const initCraftLauncherSync = require('./craft-launcher-sync');

// Import specific functions so that minor changes below are not needed.
// debug
const debug = util.debug;

// coerce
const coerceJS     = coerce.coerceJS;
const coerceString = coerce.coerceString;
const coerceNumber = coerce.coerceNumber;
const coerceBool   = coerce.coerceBool;

// fonts
const fontVariantsInFontFamily = fonts.fontVariantsInFontFamily;

// type styles
const NSFontFromLibraryTypeStyle = typeStyles.NSFontFromBrandAITypeStyle;
const sketchTextStyleFromLibraryTypeStyle = typeStyles.sketchTextStyleFromBrandAITypeStyle;
const brandAITypeStyleFromSketchSharedStyle = typeStyles.brandAITypeStyleFromSketchSharedStyle;

// colors
const stringForMSColor = colors.stringFromMSColor;
const hashForMSColor = colors.hashFromMSColor;
const MSColorFromString = colors.MSColorFromString; // Used in this file.
const NSColorFromString = colors.NSColorFromString; // Used in menus.cocoascript.


var SKETCH_VERSION;
var COSCRIPT;
var JOBS = {};

// Give the current JSContext a name. Each plugin and script gets its own
// JSContext in Sketch and by default they are all named “Untitled.” This makes
// it obvious which one is ours during debugging.
JSContext.contextWithJSGlobalContextRef(COScript.currentCOScript().context()).setName('DSM');

function display(context) {

  // Check if the window is already open.
  var pluginWindow = getPluginWindow();
  if (pluginWindow) {
    if (pluginWindow.isVisible()) {
      // Window is not expected to be released when closed, so
      // close it only if its visible.
      debug('Already open');
      exit();
    } else {
      // Window is already present, but not visible, so just show it.
      pluginWindow.makeKeyAndOrderFront(null);
    }
    return;
  }

  framework('WebKit');
  debug('Launching...');
  COSCRIPT = [COScript currentCOScript];
  [COSCRIPT setShouldKeepAround:true];
  var defaults = [NSUserDefaults standardUserDefaults];

  // Get version number.
  SKETCH_VERSION = NSBundle.mainBundle().infoDictionary()
    .CFBundleShortVersionString.UTF8String();

  // Get the plugin identifier.
  IDENTIFIER = context.command.pluginBundle().identifier();

  initCraftLauncherSync(IDENTIFIER);

  debug('Version ' + VERSION);

  // Load nib.
  debug('Loading nib...');
  var outlets = [
    'mainWindow',
    'mainWebView',
    'progressSheet',
    'progressIndicator',
    'progressLabel',
    'versionLabel',
    'lastUpdatedLabel',
    'replaceImageWindow',
    'replaceImageReplaceButton',
    'replaceImageCreateNewButton',
    'replaceImageCancelButton',
    'replaceImageSkipButton',
    'replaceImageNewItemNameLabel',
    'replaceImageNewItemWebView',
    'replaceImageOldItemNameLabel',
    'replaceImageOldItemWebView',
    'replaceImageAcceptForAll',
    'addColorsSheet',
    'addColorsWebView',
    'addColorsCancelButton',
    'addColorsAddButton',
    'manageTypeStylesSheet',
    'manageTypeStylesWebView',
    'manageTypeStylesCancelButton',
    'manageTypeStylesActionButton',
    'manageTypeStylesAddButton',
    'manageSharedStylesSheet',
    'manageSharedStylesWebView',
    'manageSharedStylesCancelButton',
    'manageSharedStylesActionButton',
    'manageSharedStylesSelectAllCheckbox',
    'versionNameTextField',
    'versionDescriptionTextField',
    'createVersionButton',
    'cancelVersionButton',
    'createVersionSheet',
    'learMoreAboutVersions',
    'manageSymbolsSheet',
    'manageSymbolsWebView',
    'manageSymbolsCancelButton',
    'manageSymbolsDeleteButton',
    'selectiveSyncSheet',
    'selectiveSyncWebView',
    'selectiveSyncCancelButton',
    'selectiveSyncImportButton'
  ];
  var nib = new NibUI(context, 'UIBundle', 'Main', outlets);

  /* Set starting UI state.
     ---------------------- */

  // Original user preferred window height
  var preferredWindowHeight = nib.mainWindow.frame().size.height;

  // Display version number.
  [(nib.versionLabel) setStringValue:(VERSION)];

  // Restore last section name.
  var lastSelectedSection = defaults.stringForKey('DsmSelectedType') || 'components';
  var lastSelectedFolder = defaults.stringForKey('DsmSelectedFolderId');

  // Save web view so we don’t have to pass it around.
  persist.set('dsmMainWebView', nib.mainWebView);


  /* Connect UI actions.
     ------------------- */

  debug('Attaching actions');

  nib.attachTargetAndAction(nib.addColorsCancelButton, function() {
    nib.mainWindow.endSheet(nib.addColorsSheet);
  });

  nib.attachTargetAndAction(nib.manageTypeStylesCancelButton, function() {
    nib.mainWindow.endSheet(nib.manageTypeStylesSheet);
  });

  nib.attachTargetAndAction(nib.manageSharedStylesCancelButton, function() {
    nib.mainWindow.endSheet(nib.manageSharedStylesSheet);
  });

  nib.attachTargetAndAction(nib.manageSymbolsCancelButton, function() {
    nib.mainWindow.endSheet(nib.manageSymbolsSheet);
  });

  nib.attachTargetAndAction(nib.selectiveSyncCancelButton, function() {
    nib.mainWindow.endSheet(nib.selectiveSyncSheet);
  });

  nib.attachTargetAndAction(nib.cancelVersionButton, function(){
    nib.mainWindow.endSheet(nib.createVersionSheet);
  });


  nib.attachTargetAndAction(nib.learMoreAboutVersions, function(){
    NSWorkspace.sharedWorkspace().openURL(NSURL.URLWithString("https://blog.brand.ai/introducing-version-control-for-design-systems-d105796369bc"));
  });

  nib.attachTargetAndAction(nib.createVersionButton, function(){
    const versionName = coerceString(nib.versionNameTextField.stringValue()).trim();
    if (!versionName){
      displayAlert({title: "Missing something?", description: 'Please provide a name for your version.'});
      return;
    }
    const versionDescription = coerceString(nib.versionDescriptionTextField.string()).trim();
    nib.mainWindow.endSheet(nib.createVersionSheet);
    postWebUIEvent('onCreateNewVersion', {name: versionName, description: versionDescription});
  });



  /* Set up event handlers.
     ---------------------- */
  var nativeUIEventFunctions = {
    getSharedStyleArchiveData: function(id) {
      const layerStyle = findSharedStyleById(MSDocument.currentDocument(), id);

      if (layerStyle) {
        const archiveData = archive.archiveDataFromSketchObject(layerStyle);
        return util.dataURLFromData(archiveData, 'application/x-skla');
      }
    },

    getSharedStylePreviewImageData: function(id) {
      const layerStyle = findSharedStyleById(MSDocument.currentDocument(), id);

      if (layerStyle) {
        const pngData = layerExport.imagePreviewForLayerStyle(layerStyle, 40);
        return util.dataURLFromData(pngData, 'image/png');
      }
    },

    getDefaultsString: function(key) {
      return coerceJS(
        NSUserDefaults.standardUserDefaults().stringForKey(key)
      );
    },

    displayAlert: function(args) {
      var alertModalName = args.alertModalName;
      if (alertModalName && alertModalName.toString){
        return displayNamedAlert(alertModalName);
      }
      return displayAlert(args);
    },

    getCachedImageData: function(payload) {
      return localImageCache.readDataFromFile(payload);
    },

    getCraftManagerToken: function() {
      const craftManagerDefaults = [[NSUserDefaults alloc] initWithSuiteName:"com.invisionlabs.CraftManager"];
      var refreshToken = craftManagerDefaults.stringForKey('com.invisionlabs.Sync.refreshToken');
      return refreshToken;
    },

    //update style data when new data is loaded/updated
    setStyleData: function(styleData) {
      var styleguideId = styleData.styleguide['_id'];
      persist.set('dsmStyleData', styleData);
      [defaults setObject:styleguideId forKey:getKeyName('StyleguideId')];
      return true;
    },

    setUserData(payload){
      saveLoginDataInDefaults(payload);
    }
  };

  var nativeUIEventHandlers = {
    onDebug: function(msg) {
      debug(msg);
    },

    // Delay posting the open window event until the web ui has finished
    // loading.
    onWebUIDidFinishLoading: function() {
      debug('web UI has loaded');

      // Set elastic scrolling for web view. Feels more like native UI.
      var scrollView = nib.mainWebView.mainFrame().frameView()
        .documentView().enclosingScrollView();
      scrollView.setVerticalScrollElasticity(NSScrollElasticityAutomatic);
      scrollView.setHorizontalScrollElasticity(NSScrollElasticityAutomatic);

      const pluginVersionReportedBySketch =
        'v' + context.command.pluginBundle().version();
      const needsRestart = pluginVersionReportedBySketch != VERSION;

      localImageCache.createImageCacheDirectory();

      var { idToken, refreshToken, domainInfo } = getLoginDataFromDefaults();

      var styleguideId = defaults.stringForKey(getKeyName('StyleguideId'));

      var layerCounts = getSelectedLayerCount();
      postWebUIEvent('onLaunchPlugin', {
        initialIdToken: coerceString(idToken),
        refreshToken: coerceString(refreshToken),
        styleguideId: coerceString(styleguideId),
        selectedType: coerceString(lastSelectedSection),
        selectedFolderId: coerceString(lastSelectedFolder),
        pluginVersion: VERSION,
        sketchVersion: SKETCH_VERSION,
        needsRestart: needsRestart,
        selectedLayerCount: layerCounts.selectedLayerCount,
        selectedArtboardCount: layerCounts.selectedArtboardCount,
        domainInfo: coerceJS(domainInfo)
      });
    },

    onOpenURLInBrowser: function(urlString) {
      NSWorkspace.sharedWorkspace().openURL(NSURL.URLWithString(urlString));
    },

    onPossibleImageDrop: function(img) {
      handlePossibleImageDrop(context.command, img);
    },

    onPossibleTypeStyleDrop: function(typeStyle) {
      handlePossibleTypeStyleDrop(context, typeStyle);
    },

    onContextMenu: function(payload) {
      genericContextMenu(payload, nib, postWebUIEvent);
    },

    onApplicationContextMenu: function(payload) {
      var menu = applicationSettingsMenu(payload, context, nib, handleLogout.bind(this, true));

      if (menu) {
        //we want the menu to be opened in the same place all the time so passing constant coordinates
        //according to view limitation, for example if there is not place at the bottom of the screen it will moved up
        popUpContextMenuInWebView(menu, nib.mainWebView, {x: 8, y: 30});
      }
    },


    onStyleguideSectionChanged: function(payload){
      [defaults setObject:payload.type forKey:'DsmSelectedType'];
      
      if (payload.folderId !== undefined) {
        [defaults setObject:payload.folderId forKey:'DsmSelectedFolderId'];
      } else {
        [defaults setObject:null forKey:'DsmSelectedFolderId'];
      }
    },


    onChangeMainWindowSize: function(payload){
      if (!payload.height || !payload.width){
        return;
      }
      var currentFrame = nib.mainWindow.frame();
      resizeFrameToNewHeightExpandingDown(nib, currentFrame, payload.height, payload.width);
    },

    onPresentAuthModal: function(options){

      var pluginWindow = getPluginWindow();
      if (!pluginWindow || !pluginWindow.isVisible()) {
        return;
      }

      if (options.shown) {
        displayAuthLogin(nib, preferredWindowHeight);
      }
    },

    onResizeToLoginScreen: function() {
      debug('resize to login screen')
      resizeToLoginScreenSIze(nib);
    },

    onChooseColor: function(payload) {
      const activeWindow = NSApplication.sharedApplication().mainWindow();
      if (activeWindow && activeWindow.class() == 'MSDocumentWindow') {
        const document = activeWindow.document();
        const selection = selectedLayersInDocument(document);
        var anyLayersWereStyled = false;
        $.forEach(selection, function(layer) {
          const anyLocalLayersWereStyled =
            updateLayerColor(layer, payload.color, payload.preferBorders);
          anyLayersWereStyled = anyLayersWereStyled || anyLocalLayersWereStyled;
        });

        if (anyLayersWereStyled) {
          document.reloadInspector();
          track('Layer.Color', 'Set');
        } else {
          NSBeep();
        }
      }
    },

    onChooseSharedStyle: function(sharedStyle) {
      resetImportSession();

      const activeWindow = NSApplication.sharedApplication().mainWindow();
      if (activeWindow && activeWindow.class() == 'MSDocumentWindow') {

        const document = activeWindow.document();
        const selection = selectedLayersInDocument(document);

        var anyLayersWereStyled = false;
        var importedLayerStyle;

        var styleData = persist.get('dsmStyleData');
        var currentlyImportedSharedStyles = libraryImportedSharedStyles(document, styleData);

        $.forEach(selection, function(layer) {
          if (layer.className() == 'MSShapeGroup') {
            debug('Applying shared layer style on layer ' + layer.name());

            if (!anyLayersWereStyled) {
              // If this is the first layer that we are
              // going to style, import the shared layer
              // style to the document now.

              importedLayerStyle = addOrUpdateSharedLayerStyle(
                document,
                context.command,
                currentlyImportedSharedStyles,
                sharedStyle
              );
            }

            // Update the layer to reflect the current share style.
            layer.setStyle(importedLayerStyle.style().copy());

            // Link the layer to the shared style.
            layer.style().setSharedObjectID(importedLayerStyle.objectID());

            anyLayersWereStyled = true;
          }
        });

        if (anyLayersWereStyled) {
          document.reloadInspector();
          track('Layer.Style', 'Set');
        } else {
          NSBeep();
        }
      }
    },

    onChooseTypeStyle: function(payload) {
      resetImportSession();

      const activeWindow = NSApplication.sharedApplication().mainWindow();
      if (activeWindow && activeWindow.class() == 'MSDocumentWindow') {

        const document = activeWindow.document();
        const selection = selectedLayersInDocument(document);
        var anyLayersWereStyled = false;

        const typeStyle = payload.typeStyle;

        var styleData = persist.get('dsmStyleData');
        var currentlyImportedTextStyles = libraryImportedTextStyles(document, styleData);

        var importedTextStyle;

        $.forEach(selection, function(layer) {
          if (layer.class() == 'MSTextLayer') {
            debug('Applying text style on layer ' + layer.name());

            // If the text was being edited, stop doing that
            // now, otherwise when editing finishes, it will
            // overwrite what we are about to do.
            if (layer.isEditingText()) {
              const editAction = MSEditAction.alloc().initWithDocument(document);
              editAction.doPerformAction(null);
            }

            if (!anyLayersWereStyled) {
              // If this is the first layer to be styled, import
              // the shared text style to the document now.

              importedTextStyle = addOrUpdateSharedTextStyle(
                document,
                context.command,
                currentlyImportedTextStyles,
                typeStyle
              );
            }

            // Update the layer to reflect the current shared style.
            layer.style().setTextStyle(importedTextStyle.style().textStyle());

            // Link the layer to the shared style.
            layer.style().setSharedObjectID(importedTextStyle.objectID());

            anyLayersWereStyled = true;
          }

        });

        if (anyLayersWereStyled) {
          document.reloadInspector();
          track('TypographyStyle', 'Set');
        } else {
          NSBeep();
        }
      }
    },

    onAddColors: function(payload) {
      const newPaletteName = payload.paletteID ? null : displayPrompt({
        title: 'New palette name',
        defaultText: 'Untitled palette',
        buttons: ['Add Palette', 'Cancel']
      });

      if (payload.paletteID || newPaletteName != null) {

        const document = MSDocument.currentDocument();
        const colorSections = [];

        //todo: filter existing colors in the library from this list?
        const colorsFromSelectedLayers =
          $.map(getLayersColors(selectedLayersInDocument(document)), stringForMSColor);

        if (colorsFromSelectedLayers.length) {
          colorSections.push({
            name: 'Colors from selected layers',
            colors: colorsFromSelectedLayers
          });
        }

        const documentColors = $.map(
          document.documentData().assets().colors(),
          stringForMSColor
        );

        //we want to filter from document colors of all the parents colors so they will not be suggested as possible additions to the derived styleguide
        var styleData = persist.get('dsmStyleData');
        var parentsColors = []; //create a flat list of all parents color values
        styleData.globalAssets.colors.forEach(function(color){
          if (color.styleguideId != styleData.styleguide._id){
            parentsColors.push(color.value);
          }
        });

        var documentColorsToAdd = documentColors.filter(function(documentColor){
          return !parentsColors.includes(documentColor);
        });

        if (documentColorsToAdd.length) {
          colorSections.push({
            name: 'Document colors',
            colors: documentColorsToAdd
          });
        }

        const globalColors = $.map(
          NSApp.delegate().globalAssets().colors(),
          stringForMSColor
        );
        if (globalColors.length) {
          colorSections.push({
            name: 'Global colors',
            colors: globalColors
          });
        }

        const addColorsApp = loadReactAppInWebView(context.plugin, nib.addColorsWebView, 'AddColorsApp', {
          onReady: function() {
            addColorsApp.setColors(colorSections);
            [(nib.mainWindow) beginSheet:(nib.addColorsSheet) completionHandler:null];
          },
          onSelectionChanged: function(itemCount) {
            nib.addColorsAddButton.setEnabled(itemCount > 0);
          }
        });

        // Start with disabled button since no colors will be selected.
        nib.addColorsAddButton.setEnabled(false);

        nib.attachTargetAndAction(nib.addColorsAddButton, function() {
          addColorsApp.getSelectedColors(function(err, colors) {
            nib.mainWindow.endSheet(nib.addColorsSheet);
            postWebUIEvent('onAddNewColors', {
              newPaletteName: newPaletteName,
              sectionID: payload.paletteID,
              folderId: payload.folderId,
              colors: colors
            });
          });
        });
      }

    },


    onAddTypeStyles: function(payload) {
      const document = MSDocument.currentDocument();
      const textStyles = getDocumentTextStyles(document);

      if (textStyles.count() == 0) {
        displayAlert({
          title: 'No text styles to upload',
          description: 'The current Sketch document has no text styles.'
        });
        return;
      }

	    var styleData = persist.get('dsmStyleData');
	    var parentsTypeStyles = []; //create a flat list of all parents type styles ids
	    styleData.globalAssets.typeStyles.forEach(function(type){
		    if (type.styleguideId != styleData.styleguide._id){
			    parentsTypeStyles.push(type._id);
		    }
	    });

      const typeStyleIDsBySharedTextStyleObjectID = brandaiIdByTextStyleIdMap(document, styleData);

      var typeStylesToAdd = [];
	    $.forEach(textStyles, function(textStyle) {
		    // Find Brand.ai _id, for shared text styles in the document that have one.
		    const libraryID = typeStyleIDsBySharedTextStyleObjectID[textStyle.objectID()];
		    // If it is unsynced typeStyle and if it is not part of parent styleguides set it on the style and add the style to candidates list
        if (!libraryID || !parentsTypeStyles.includes(libraryID.trimRight())) {
			    const typeStyle = brandAITypeStyleFromSketchSharedStyle(textStyle);
			    typeStyle.folderId = payload.folderId;
			    if (libraryID && libraryID != null) {
				    typeStyle._id = libraryID;
			    }
			    typeStylesToAdd.push(typeStyle);
		    }
	    });

      manageTypeStylesApp(context, nib, typeStylesToAdd, 'objectID', 'Add', function(chosenTypeStyles) {
        const fontVariants = {};
        chosenTypeStyles.forEach(function(typeStyle) {
          if (!fontVariants[typeStyle.fontFamily]) {
            fontVariants[typeStyle.fontFamily] =
              fontVariantsInFontFamily(typeStyle.fontFamily);
          }
        });
        postWebUIEvent('onSaveTypeStyles', { typeStyles: chosenTypeStyles, fontVariants });
      });
    },

    openDeleteTypeStylesApp: function() {
      debug('native: onOpenDeleteTypeStylesApp');

      var styleData = persist.get('dsmStyleData');
      var typeStyles = styleData.styleguide.typeStyles || [];

      manageTypeStylesApp(context, nib, typeStyles, '_id', 'Delete', function(chosenTypeStyles) {

        //This list will not be empty at this point
        var idsToDelete = chosenTypeStyles.map(function(typeStyle){
          return typeStyle._id;
        });

        postWebUIEvent('onDeleteItems', { type: 'typeStyles', elementIDs: idsToDelete });
      });
    },

    onAddSharedStyles: function(payload) {
      const document = MSDocument.currentDocument();
      const layerStyles = getDocumentSharedLayerStyles(document);

      if (layerStyles.count() == 0) {
        displayAlert({
          title: 'No layer styles to upload',
          description: 'The current Sketch document has no layer styles.'
        });
        return;
      }

      var styleData = persist.get('dsmStyleData');

      var parentsSharedStyles = []; //create a flat list of all parents shared styles ids
      styleData.globalAssets.sharedStyles.forEach(function(style) {
        if (style.styleguideId != styleData.styleguide._id) {
          parentsSharedStyles.push(style._id);
        }
      });

      const brandaiIDsByLayerStyleObjectID = brandaiIdBySharedStyleIdMap(document, styleData);


      var sharedStylesToAdd = [];
      $.forEach(layerStyles, function(layerStyle) {
        const sharedStyle = brandAISharedStyleFromSketchSharedStyle(layerStyle);
        // Add Brand.ai _id, for shared styles in the document that have one.
        const libraryID = brandaiIDsByLayerStyleObjectID[layerStyle.objectID()];

        // If it is unsynced sharedStyle and if it is not part of parent styleguides set it on the style and add the style to candidates list
        if (!libraryID || !parentsSharedStyles.includes(libraryID.trimRight())) {
          if (libraryID && libraryID != null) {
            sharedStyle._id = libraryID;
          }
          const pngData = layerExport.imagePreviewForLayerStyle(layerStyle, 24);
          const thumbnailFilePath = util.getTempFilePath('Brand-ai-Sketch-layerStyle' + layerStyle.objectID(), 'png');
          [pngData writeToFile:thumbnailFilePath atomically:false];
          sharedStyle.thumbnailUrl = thumbnailFilePath;
          sharedStyle.folderId = payload.folderId;

          sharedStylesToAdd.push(sharedStyle);
        }
      });

      manageSharedStylesApp(context, nib, sharedStylesToAdd, 'objectID', 'Add', function(choseSharedStyles) {
        postWebUIEvent('onSaveSharedLayerStyles', choseSharedStyles);
      });
    },

    openDeleteSharedStylesApp: function() {

      var styleData = persist.get('dsmStyleData');
      var sharedStyles = styleData.styleguide.sharedStyles || [];

      manageSharedStylesApp(context, nib, sharedStyles, '_id', 'Delete', function(chosenSharedStyles) {
        //This list will not be empty at this point
        var idsToDelete = chosenSharedStyles.map(function(sharedStyle){
          return sharedStyle._id;
        });
        postWebUIEvent('onDeleteItems', { type: 'sharedStyles', elementIDs: idsToDelete });
      });
    },

    onWindowDidBlur: function() {
      addFirstMouseAcceptor(nib);
    },

    // Upload layers - stage #2
    onUploadLayers: function(payload) {
      const document = MSDocument.currentDocument();
      const selectedLayers = normalizeSelectedSymbols(selectedLayersInDocument(document));

      if (selectedLayers.count() == 0) {
        displayAlert({
          title: 'No layers to upload',
          description: 'Select at least one layer.'
        });
        return;
      }

      var newSection;
      var newSectionName;

      if (!payload.sectionID) {
        // Uploading to a new section.
        newSectionName = displayPrompt({
          title: 'New section',
          defaultText: document.currentPage().name(),
          description: 'Choose a name for the new section to upload layers into.',
          buttons: ['Upload', 'Cancel']
        });

        if (!newSectionName) {
          // User did not supply a section name;
          return;
        }

        // The new section type should match the area where the layers were
        // uploaded from.
        newSection = {
          name: newSectionName,
          imageType: payload.imageType,
          folderId: payload.folderId
        };
      }

      const styleData = persist.get('dsmStyleData');

      const candidatesData = processLayerCandidates(nib, document, payload, styleData, selectedLayers, newSection, newSectionName);

      const layersChosenForUpload = candidatesData.layersChosenForUpload;
      const layersToUpload = candidatesData.layersToUpload;
      const layersToUploadByID = candidatesData.layersToUploadByID;


      const brandAITypeStyleIDsByTextStyleID = brandaiIdByTextStyleIdMap(document, styleData);
      const brandAISharedStyleIDsByLayerStyleID = brandaiIdBySharedStyleIdMap(document, styleData);
      const documentSharedStylesById = getDocumentSharedStylesById(document);
      const documentTextStylesById = getDocumentTextStylesById(document);


      const symbolMasterDependencies = symbolMasterDependenciesForLayers(document, layersChosenForUpload);

      const layersToUploadCount = layersToUpload.length + symbolMasterDependencies.length;
      const ui = new UI(nib);
      ui.showProgressSheet('(1/5) Exporting layers…', layersToUploadCount);

      // Get all the layer data.
      layersToUpload.forEach(function(layerInfo) {
        const layer = layersToUploadByID[layerInfo.id];

        layerInfo.exportedData = coerceJS(
          layerExport.exportLayerInFormatsForType(document, layer, payload.imageType)
        );

        const sharedObjects = coerceJS(dependencyHelpers.sharedObjectsForLayer(
          layer,
          documentTextStylesById,
          documentSharedStylesById,
          brandAITypeStyleIDsByTextStyleID,
          brandAISharedStyleIDsByLayerStyleID
        ));
        Object.assign(layerInfo, sharedObjects);
        ui.incrementProgress();
      });

      symbolMasterDependencies.forEach(function(symbol) {
        layersToUploadByID[symbol.objectID()] = symbol;

        const sharedObjects = dependencyHelpers.sharedObjectsForLayer(
          symbol,
          documentTextStylesById,
          documentSharedStylesById,
          brandAITypeStyleIDsByTextStyleID,
          brandAISharedStyleIDsByLayerStyleID
        );

        layersToUpload.push(coerceJS(Object.assign(
          {
            id: symbol.objectID(),
            name: symbol.name(),
            isSymbolMasterDependency: true,
            symbolID: symbol.symbolID(),
            exportedData: layerExport.exportLayerInFormatsForType(
              document,
              symbol,
              'sketchSymbols',
              {
                isSymbolMasterDependency: true
              }
            )
          },
          sharedObjects
        )));
        ui.incrementProgress();
      });

      // Add in all dependencies of the layers that will be uploaded as well.
      const styleDependencies = dependencyHelpers.styleDependenciesForLayers(
        styleData,
        layersToUploadByID,
        documentTextStylesById,
        documentSharedStylesById,
        brandAITypeStyleIDsByTextStyleID,
        brandAISharedStyleIDsByLayerStyleID
      );

      debug('Layers to upload (' + layersToUpload.length + '):');
      debug(layersToUpload);
      debug('New section:');
      debug(newSection);
      debug('Shared layer styles to upload:');
      debug(styleDependencies.sharedLayerStylesToUpload);
      debug('Shared type styles to upload:');
      debug(styleDependencies.sharedTypeStylesToUpload);
      debug('Font variants to upload:');
      debug(styleDependencies.fontVariantsToUpload);

      if (layersToUpload.length) {
        postWebUIEvent('onUploadLayers', {
          newSection: newSection,
          layersToUpload: layersToUpload,
          sharedLayerStylesToUpload: styleDependencies.sharedLayerStylesToUpload,
          sharedTypeStylesToUpload: styleDependencies.sharedTypeStylesToUpload,
          fontVariantsToUpload: styleDependencies.fontVariantsToUpload
        });
      }
    },

    onRestartSketch: function() {
      const pid = coerceString(NSProcessInfo.processInfo().processIdentifier());
      const appPath = NSBundle.mainBundle().bundlePath();
      const helperPath = context.command
        .pluginBundle()
        .url()
        .URLByAppendingPathComponent('Contents/Sketch/restart-helper.rb')
        .path();
      NSTask.launchedTaskWithLaunchPath_arguments('/usr/bin/ruby', [
        helperPath,
        pid,
        appPath
      ]);
      NSApp.terminate(null);
    },

    onTypeStylesDidLoad: function(typeStyles) {
      const installedFonts = {};
      (typeStyles || []).forEach(function(typeStyle) {
        // we can reach this flow with mormalized and unnormalized type styles adjust so that it will work with both
        if (typeStyle.fontFamilyObject) {
          typeStyle.fontFamily = typeStyle.fontFamilyObject.family;
        }

        const font = NSFontFromLibraryTypeStyle(typeStyle);
        if (font) {
          installedFonts[typeStyle._id] = coerceJS(font.fontName());
        }
      });
      postWebUIEvent('onInstalledFontsAvailable', installedFonts);
    },


    onRunJob: function(jobId) {
      const job = JOBS[jobId];
      if (job) {
        try {
          job();
          postWebUIEvent('onJobDidFinish', jobId);
          JOBS[jobId] = null;
        } catch(e) {
          if (JOBS.errorHandler) {
            JOBS.errorHandler(e);
          } else {
            debug('No job error handler for job ' + jobId + 'error on next line:');
            debug(e);
          }
        }
      }
    },

    onAllJobsDidFinish: function() {
      if (JOBS.completionHandler) {
        JOBS.completionHandler();
      }
    },

    onCallFunction: function(payload) {
      postWebUIEvent('onCallback', {
        callbackID: payload.callbackID,
        payload: coerceJS(nativeUIEventFunctions[payload.functionName](payload.args))
      });
    },

    onSetDefaultsObject: function(payload) {
      if (!payload.value) {
        payload.value = null;
      }
      [[NSUserDefaults standardUserDefaults] setObject:(payload.value)
        forKey:(payload.key)];
    },

    onShowProgresSheet: function(payload) {
      (new UI(nib)).showProgressSheet(payload.label, payload.maxValue);
    },

    onHideProgressSheet: function() {
      (new UI(nib)).hideProgressSheet();
    },

    onIncrementProgress: function(incrementBy) {
      (new UI(nib)).incrementProgress(incrementBy);
    },

    onImageFallbackDataReceived: function(payload) {
      localImageCache.writeDataToFile(payload);
    },

    onUpdateDocument: function(){
      importStyleData(context, nib, null, true);
    }

  };


  var webUIDelegate = util.createCocoaObject({
    // This is a hack to receive data from the web view since
    // windowScriptObject doesn’t work.
    'webView:setStatusText:': function(webView, statusText) {
      if (!statusText || statusText == '') {
        // Empty strings are expected when the view first loads; just ignore it.
        return;
      }
      try {
        var passedData = JSON.parse(statusText);
      } catch (e) {
        debug("Unable to parse status text \"" + statusText + "\"");
        return;
      }
      var eventName = passedData.eventName;
      var payload = passedData.payload;
      var handler = nativeUIEventHandlers[eventName];
      if (!handler) {
        debug("No event handler for native UI event \"" + eventName + "\"");
      } else {
        try {
          handler.call(null, payload);
        } catch(e) {
          // For some reason errors are not logged unless we do this:
          log(e.toString());
          log(e.stack);

          logMessage( 'error', { message: 'postNativeUIEvent error: ' + e.toString(), eventName: eventName, payload: payload, stack: e.stack });
        }
      }
    }
  });
  nib.mainWebView.setUIDelegate(webUIDelegate);

  /* Launch plugin
     ------------- */

  // Load web environment (local html file)
  nib.mainWebView.preferences().setCacheModel(WebCacheModelDocumentBrowser);
  loadReactAppInWebView(context.plugin, nib.mainWebView, 'MainApp');

  // Show window.
  nib.mainWindow.makeKeyAndOrderFront(null);

  nib.destroy();
}

function importCraftLibrary(nib) {
  const openPanel = NSOpenPanel.openPanel();
  openPanel.setPrompt('Import');
  if (openPanel.runModalForTypes(['library'])) {
    const libraryURL = openPanel.URLs().firstObject();
    util.defer(function() {
      const ui = new UI(nib);
      try {
        function onStart(itemCount) {
          ui.showProgressSheet('Reading Craft Library…', itemCount);
        }
        function onProgress() {
          ui.incrementProgress();
        }

        const imported = craftImport.readLibrary(libraryURL, onStart, onProgress);

        var shouldContinueImporting = true;

        if (imported.importProblems.length > 0) {
          const listOfProblems =
            imported.importProblems.map(function(err) {
              log(err.toString());
              log(err.stack);
              logMessage('error', {
                message: err.message,
                itemDesc: err.itemDesc,
                library: err.libraryPath,
                filePath: err.filePath
              });
              return err.toUIString();
            }).join('\n\n');

          const title =
            (
              imported.importProblems.length === 1
              ? '1 symbol'
              : imported.importProblems.length + ' symbols'
            ) +
            ' couldn’t be read';

          const description =
            'Some of your symbols might not work in Sketch. ' +
            'Do you want to continue importing this library?';

          const alertResult = displayAlert({
            title: title,
            description: description,
            style: 'error',
            buttons: ['Continue…', 'Cancel'],
            accessoryView: util.createScrollingTextView(
              listOfProblems,
              NSMakeRect(0, 0, 295, 100),
              NSFont.smallSystemFontSize()
            )
          });

          shouldContinueImporting = alertResult === NSAlertFirstButtonReturn;
        }

        if (shouldContinueImporting) {
          postWebUIEvent('onImportCraftLibrary', { importedLibrary: imported.library });
        } else {
          ui.hideProgressSheet();
        }

      } catch (err) {
        ui.hideProgressSheet();
        log(err.toString());
        log(err.stack);
        logMessage('error', {
          message: err.message,
          itemDesc: err.itemDesc,
          library: err.libraryPath,
          filePath: err.filePath
        });

        if (err instanceof craftImport.CraftLibReadError) {
          displayAlert({
            title: 'Your library wasn’t imported',
            description: 'We had trouble reading this Craft library. ' +
              'Try uploading it manually from a Sketch file instead.',
            style: 'error'
          });
        } else {
          displayAlert({
            title: 'Error reading Craft library',
            description: err.message || err.toString(),
            style: 'error'
          });
        }
      }
    });
  }
}

function manageSymbolsApp(context, nib) {

  var styleData = persist.get('dsmStyleData');

  //currently sending only this styleguide and not parent symbols
  var masterSymbols = [];

  const directLibrarySymbolsById = {};
  applyToAllImages(styleData, function(image, imageType, sectionId) {
    if (image.metadata && image.metadata.sketchSymbolId) {
      directLibrarySymbolsById[image.metadata.sketchSymbolId] = { image: image };
    }
  });

  styleData.styleguide.sketchSymbols.forEach(function(symbol){
    // we will allow for deletion only symbols that are not directly in the design library
    if (!directLibrarySymbolsById[symbol.metadata.sketchSymbolId]){
      masterSymbols.push(symbol);
    }
  });

  const manageSymbolsApp = loadReactAppInWebView(context.plugin, nib.manageSymbolsWebView, 'ManageSymbolsApp', {
    onReady: function() {
      manageSymbolsApp.setSymbols(masterSymbols);
      [(nib.mainWindow) beginSheet:(nib.manageSymbolsSheet) completionHandler:null];
    },
    onSelectionChanged: function(selectedCount) {
      nib.manageSymbolsDeleteButton.setEnabled(selectedCount > 0);
    }
  });

  // Button starting states.
  nib.manageSymbolsDeleteButton.setEnabled(false);

  nib.attachTargetAndAction(nib.manageSymbolsDeleteButton, function() {
    manageSymbolsApp.getSelectedSymbols(function(err, selectedSketchSymbols) {
      nib.mainWindow.endSheet(nib.manageSymbolsSheet);
      if (selectedSketchSymbols.length && selectedSketchSymbols.length > 0) {
        const idsToDelete = selectedSketchSymbols.map(function(symbol){
          return symbol._id;
        })
        postWebUIEvent('onDeleteItems', { type: 'sketchSymbols', elementIDs: idsToDelete, customDescription: 'Deleting nested symbols which are in use might break the containing layers.\nYou can’t undo this action.' });
      }
    });
  });
};

function manageTypeStylesApp(context, nib, inputTypeStyles, idKey, actionName, onCompleteCallback){

  nib.manageTypeStylesActionButton.title = actionName + ' Text Styles';

  const manageTypeStylesApp = loadReactAppInWebView(context.plugin, nib.manageTypeStylesWebView, 'ManageTypeStylesApp', {
    onReady: function() {
      manageTypeStylesApp.setTypeStyles(inputTypeStyles, idKey);
      [(nib.mainWindow) beginSheet:(nib.manageTypeStylesSheet) completionHandler:null];
    },
    onSelectionChanged: function(selectedCount, totalCount) {
      nib.manageTypeStylesActionButton.setEnabled(selectedCount > 0);
      nib.manageTypeStylesAddButton.setState(selectedCount == totalCount);
    }
  });

  // Button starting states.
  nib.manageTypeStylesActionButton.setEnabled(false);
  nib.manageTypeStylesAddButton.setState(NSOffState);

  nib.attachTargetAndAction(nib.manageTypeStylesActionButton, function() {
    manageTypeStylesApp.getSelectedTypeStyles(function(err, typeStyles) {
      nib.mainWindow.endSheet(nib.manageTypeStylesSheet);
      onCompleteCallback(typeStyles);
    });
  });

  nib.attachTargetAndAction(nib.manageTypeStylesAddButton, function() {
    manageTypeStylesApp.toggleSelectAll();
  });
}

function manageSharedStylesApp(context, nib, inputSharedStyles, idKey, actionName, onCompleteCallback){

  nib.manageSharedStylesActionButton.title = actionName + ' Shared Styles';

  const manageSharedStylesApp = loadReactAppInWebView(
    context.plugin,
    nib.manageSharedStylesWebView, 'ManageSharedStylesApp', {
      onReady: function() {
        manageSharedStylesApp.setSharedStyles(inputSharedStyles, idKey);
        [(nib.mainWindow) beginSheet:(nib.manageSharedStylesSheet) completionHandler:null];
      },
      onSelectionChanged: function(selectedCount, totalCount) {
        nib.manageSharedStylesActionButton.setEnabled(selectedCount > 0);
        nib.manageSharedStylesSelectAllCheckbox.setState(selectedCount == totalCount);
      }
    }
  );

  // Button starting states.
  nib.manageSharedStylesActionButton.setEnabled(false);
  nib.manageSharedStylesSelectAllCheckbox.setState(NSOffState);

  nib.attachTargetAndAction(nib.manageSharedStylesActionButton, function() {
    manageSharedStylesApp.getSelectedSharedStyles(function(err, sharedStyles) {
      nib.mainWindow.endSheet(nib.manageSharedStylesSheet);
      onCompleteCallback(sharedStyles);
    });
  });

  nib.attachTargetAndAction(nib.manageSharedStylesSelectAllCheckbox, function() {
    manageSharedStylesApp.toggleSelectAll();
  });

}

function selectiveSyncApp(context, nib) {

  var styleData = persist.get('dsmStyleData');

  const selectiveSyncApp = loadReactAppInWebView(context.plugin, nib.selectiveSyncWebView, 'SelectiveSyncApp', {
    onReady: function() {
      //potentially can store the last selection and set it here to the app
      [(nib.mainWindow) beginSheet:(nib.selectiveSyncSheet) completionHandler:null];
    },
    onSelectionChanged: function(selectedCount) {
      nib.selectiveSyncImportButton.setEnabled(selectedCount > 0);
    }
  });

  nib.attachTargetAndAction(nib.selectiveSyncImportButton, function() {
    selectiveSyncApp.getSelectedItems(function(err, selectedOptions) {
      nib.mainWindow.endSheet(nib.selectiveSyncSheet);
      if (selectedOptions && Object.keys(selectedOptions).length > 0) {
        importStyleData(context, nib, null, false, selectedOptions);
      }
    });
  });
};


function importStyleData(context, nib, originElement, onlyExisting, typesToSync) {
  const document = [MSDocument currentDocument];
  if (document) {

    const handleImportError = function(e) {
      debug(e.name + ": " + e.message);
      logMessage('error', { message: e.name + ": " + e.message });

      postWebUIEvent('finishedUpdatingDocument');

      // Show alert modal dialog.
      displayAlert({
        title: 'Error Syncing Data',
        description: 'There was an error while trying to add styles to the document.',
        style: 'error'
      });
    }

    // Import.
    try {
      typesToSync = typesToSync || constants.TYPES_TO_SYNC;

      var reportedSyncedTypes = Object.keys(typesToSync);

      var reportedAction = onlyExisting ? 'Updated' : 'Imported';

      track('StyleData', reportedAction, { syncedTypes: reportedSyncedTypes });
      const styleData = persist.get('dsmStyleData');


      resetImportSession();

      //if undefined bring all types, is this the desired behavior?
      debug('Types To Sync:');
      debug(typesToSync);
      if (!onlyExisting && typesToSync[constants.TYPES_TO_SYNC.colors.key]) { //We can't update colors as we have no linking for them, so skip them in update mode
        importColors(context.command, document, styleData);
      }
      if (typesToSync[constants.TYPES_TO_SYNC.typeStyles.key]) {
        importTypeStyles(context.command, document, styleData, onlyExisting);
      }
      if (typesToSync[constants.TYPES_TO_SYNC.sharedStyles.key]) {
        importLayerStyles(context.command, document, styleData, onlyExisting);
      }
      if (typesToSync[constants.TYPES_TO_SYNC.symbols.key]) {
        var libraryContext = {
          librarySymbols: allLibrarySymbolsIndexedBySymbolID(styleData),
          documentSymbols: util.getSymbolsMastersByID(document),
          librarySymbolsBySize: allLibrarySymbolsIndexedBySize(styleData),
          libraryImportedTextStyles: libraryImportedTextStyles(document, styleData),
          libraryImportedSharedStyles: libraryImportedSharedStyles(document, styleData),
          allLibrarySharedStyles: allLibrarySharedStylesByUUID(styleData),
          allLibraryTextStyles: allLibraryTextStylesByUUID(styleData)
        };

        importImages(context.command, document, 'icons', styleData, onlyExisting, libraryContext);
        importImages(context.command, document, 'components', styleData, onlyExisting, libraryContext);

        libraryContext = null;
      }

      runJobs({
        onComplete: function() {

          // Some symbol instances may not have redrawn after their master
          // changed. This should fix it. Note that this works because symbol
          // instances don’t exhibit this problem when the current page is
          // the symbols page.
          const userPage = document.currentPage();
          const symbolsPage = getPageByName(document, 'Symbols');
          document.setCurrentPage(symbolsPage);
          document.setCurrentPage(userPage);
          postWebUIEvent('finishedUpdatingDocument');
        },
        onError: handleImportError
      });
    } catch (e) {
      handleImportError(e);
    }

  } else {
    debug('No current document');
  }
}


function exit() {
  var mainWindow = getPluginWindow();
  if (mainWindow) {
    // Close the main window as if the user had clicked the close button.
    mainWindow.performClose(null);
  }
}

function sendDataToWebView(webView, data) {
  const jsonData = JSON.stringify(coerceJS(data));
  debug('NATIVE->WEB: ' + jsonData);
  const script = 'window.dsm.receiveDataFromNativeUI(' + jsonData + ')';
  webView.windowScriptObject().evaluateWebScript(script);
}

function postWebUIEvent(eventName, payload) {
  var webView = persist.get('dsmMainWebView');
  if (webView) {
    var data = JSON.stringify({ eventName: eventName, payload: payload });
    var script = "window.dsm.handleEvent(" + data + ")";
    webView.windowScriptObject().evaluateWebScript(script);
  } else {
    debug('No WebView present. Event cannot be posted to the web UI.');
  }
}

function queueJob(job) {
  const jobId = Math.random().toString(36).substr(2, 10);
  JOBS[jobId] = job;
  postWebUIEvent('onQueueJob', jobId);
}

function runJobs(options) {
  options = options || {};
  JOBS.completionHandler = options.onComplete;
  JOBS.errorHandler = options.onError;
  postWebUIEvent('onStartRunningJobsInQueue');
}

function track(featureName, action, properties) {
  postWebUIEvent('onTrackData', { featureName: featureName, action: action, properties: properties });
}

function droppedLayerFromAnyDocument(layerPredicate) {
  var droppedLayer;
  var targetDocument;
  $.forEach(NSApplication.sharedApplication().windows(), function(window) {
    const document = window.document();
    if (window.class() == 'MSDocumentWindow' && document) {
      const selection = selectedLayersInDocument(document);
      if (selection.count() == 1) {
        const selectedLayer = selection.firstObject();
        if (layerPredicate(selectedLayer)) {
          droppedLayer = selectedLayer;
          targetDocument = document;
          return false;
        }
      }
    }
  });


  if (!droppedLayer) {
    //Currently in Sketch 45 there is a different behaviour than in previous versions:
    //if dropping a layer to arboard which is not currently selected calling document.selectedLayers it will not find any and will result in empty list
    //Trying to find a match with all the children of the current page of the current document. (Performance wise will not consider all the documents as the selection flow)
    debug('No selected items found, trying fallback');
    var currentDocument = MSDocument.currentDocument();
    var currentPage = currentDocument.currentPage();
    $.forEach(currentPage.children(), function(layer) {
      if (layerPredicate(layer)) {
        droppedLayer = layer;
        targetDocument = currentDocument;
        return false;
      }
    });
  }

  return {
    droppedLayer: droppedLayer,
    targetDocument: targetDocument
  };
}

function getSelectedLayerCount() {
  const document = MSDocument.currentDocument();
  var result = {
    layers: 0,
    artboards: 0
  };

  if (document) {
    const selectedLayers = selectedLayersInDocument(document);
    result = {
      selectedLayerCount: selectedLayers.count(),
      selectedArtboardCount: countLayerArtboards(selectedLayers)
    }
  }
  return result;
}

function handlePossibleTypeStyleDrop(context, typeStyle) {
  debug('Possible text drop');
  resetImportSession();
  const selected = droppedLayerFromAnyDocument(function(layer) { return layer.name() == '.....' });
  const droppedLayer = selected.droppedLayer;
  const document = selected.targetDocument;

  if (droppedLayer) {
    debug('Possible text drop: yes!');
    track('Text', 'Dropped');

    const textLayer = droppedLayer;

    var styleData = persist.get('dsmStyleData');
    var currentlyImportedTextStyles = libraryImportedTextStyles(document, styleData);

    const importedTextStyle = addOrUpdateSharedTextStyle(
      document,
      context.command,
      currentlyImportedTextStyles,
      typeStyle
    );

    // Set the layer name.
    textLayer.setStringValue(typeStyle.name);

    // Set the style of the layer according to the style data.
    textLayer.style().setTextStyle(importedTextStyle.style().textStyle());
    textLayer.style().setContextSettings(importedTextStyle.style().contextSettings());

    // Link the layer to the shared style.
    textLayer.style().setSharedObjectID(importedTextStyle.objectID());

    // With round pixel values.
    textLayer.frame().setTop(Math.round(textLayer.frame().top()));
    textLayer.frame().setLeft(Math.round(textLayer.frame().left()));

    // Select the new layer.
    [textLayer select:true byExpandingSelection:false];

    // Set the name of the layer if we have one.
    if (typeStyle.name) {
      textLayer.setName(typeStyle.name);
    }

  }
}

function handlePossibleImageDrop(command, imageData) {
  // TODO: make sure image is not dropped inside another image group?

  if (imageData.metadata && imageData.metadata.sketchSymbolId) {
    displayImageDragHelpDialog();
  }

  debug('Possible image drop');
  resetImportSession();
  const possibleLayerNames = possibleSketchLayerNamesFromURL(imageData.draggedImgSrcUrl, imageData.extension);
  debug('Looking for selected layer with one of name:');
  debug(possibleLayerNames);

  const selection = droppedLayerFromAnyDocument(function(layer) {
    const normalizedLayerName = layer.name().decomposedStringWithCanonicalMapping();
    return possibleLayerNames.find(function(possibleLayerName) {
      return NSString.stringWithString(possibleLayerName)
        .decomposedStringWithCanonicalMapping()
        .isEqualToString(normalizedLayerName);
    });
  });
  const droppedLayer = selection.droppedLayer;
  const document = selection.targetDocument;

  if (!droppedLayer) {
    logMessage( 'info', { message: 'Could not find a match for dropped image', imageData: imageData });
  } else {
    try {
      debug('Possible image drop: yes!');
      var droppedType = 'Unknown';
      const extension = imageData.sklaExtension || imageData.extension
      switch(extension) {
      case 'svg':
        debug('Droped SVG');
        track('Image', 'Dropped', { imageType: 'SVG' });
        // SVGs get dropped with a containing group already in place. So
        // all we need to do is name that group and store data on it.
        droppedLayer.setName(imageData.name);
        droppedType = 'SVG';
        break;

      case 'png':
      case 'jpeg':
      case 'jpg':
        debug('Drop Bitmap');
        track('Image', 'Dropped', { imageType: 'Bitmap' });

        // We don’t care what got dropped in the document.
        // It might be just a thumbnail. We need to remove
        // it and import the image to the same location.
        var dropParent = getParentLayer(droppedLayer);
        var targetX = droppedLayer.frame().x();
        var targetY = droppedLayer.frame().y();
        dropParent.removeLayer(droppedLayer);

        // Load the image.
        const bitmapLayer = importImage(imageData.assetKey, imageData.extension);

        if (bitmapLayer){
          // Add image layer to document.
          dropParent.addLayer(bitmapLayer);
          bitmapLayer.frame().setX(targetX);
          bitmapLayer.frame().setY(targetY);

          // Set the name of the added layer.
          bitmapLayer.setName(imageData.name);

          // Select the added layer, which mimicks the
          // behavior of dragged in layers.
          [bitmapLayer select:true byExpandingSelection:false];
        }
        break;

      case 'ai':
      case 'eps':
        debug('Drop EPS');
        track('Image', 'Dropped', { imageType: 'EPS/Illustrator' });
        // Assume that it was really a PNG that was dropped. We need to
        // replace it with an imported EPS. First do everything the same as
        // with a PNG.
        var parent = getParentLayer(droppedLayer);
        var group = MSLayerGroup.new();
        group.setName(imageData.name);
        parent.addLayers([group]);
        [MSLayerGroup moveLayers:[droppedLayer] intoGroup:group];
        [group select:true byExpandingSelection:false];
        group.resizeToFitChildrenWithOption(0);

        var EPSImageData = importImage(imageData.assetKey, imageData.extension);
        if (EPSImageData) {
          replaceGroupContents(
            group,
            EPSImageData
          );
        }
        droppedType = 'EPS';
        break;

      case 'skla':
        debug('Drop sketch layer');
        track('Layer', 'Dropped');
        // I don’t care what got dropped in the document. We need to remove it
        // and import the new layer to the same location.
        var dropParent = getParentLayer(droppedLayer);
        var targetX = droppedLayer.frame().x();
        var targetY = droppedLayer.frame().y();

        dropParent.removeLayer(droppedLayer);

        const sketchLayerURL = imageData.sklaUrl;
        const sketchLayerAssetKey = imageData.sklaAssetKey;
        const pasteboardLayers = loadSketchLayers(sketchLayerAssetKey);
        if (!pasteboardLayers){
          // displayNoImageInCacheAlert();
          debug('Not adding or updating symbol "' + imageData.name +'": could not load its sketch layer data.');
          return;
        }
        const layerToAdd = pasteboardLayers.layers().firstLayer();
        var libraryContext = createLibraryContext(pasteboardLayers, MSDocument.currentDocument());

        debug('Layer to add: ' + layerToAdd);

        // Give layer trees all new objectIDs so there are
        // no objectID duplicates in the document.
        $.forEach(layerToAdd.children(), function(layer) {
          layer.setObjectID(MSModelObjectCommon.generateObjectID());
        });

        updateSharedObjectsForLayerTree(
          command,
          document,
          libraryContext,
          layerToAdd,
          true,
          imageData
        );

        libraryContext = null;

        // Sketch may have created a symbols page behind the scenes but the
        // default behavior in that case is for the page to be hidden from the
        // user. That seems buggy. Selecting the page real quick and then going
        // back to where the user started will reveal the Symbols page in the UI.
        const symbolsPage = getPageByName(document, 'Symbols');
        if (symbolsPage) {
          const userPage = document.currentPage();
          document.setCurrentPage(symbolsPage);
          document.setCurrentPage(userPage);
        }

        // Add layer to document.
        dropParent.addLayer(layerToAdd);
        layerToAdd.frame().setX(targetX);
        layerToAdd.frame().setY(targetY);

        // If dropping an artboard, put it at the root of
        // the page instead of inside a group or artboard.
        if (layerToAdd.className() == 'MSArtboardGroup' && dropParent.className() != 'MSPage') {
          const page = getParentLayer(dropParent, MSPage);
          [layerToAdd moveToLayer:page beforeLayer:null];
        }

        // If the layer is dropped inside an artboard, but
        // ends up outside the bounds of the artboard, move
        // it up to the page level.
        const artboard = layerToAdd.parentArtboard();
        if (artboard && layerToAdd !== artboard) {
          const artboardSize = artboard.frame().rect().size;
          const relativeArtboardRect = CGRectMake(0, 0, artboardSize.width, artboardSize.height);

          if (!CGRectIntersectsRect(relativeArtboardRect, layerToAdd.frame().rect())) {
            const page = getParentLayer(dropParent, MSPage);
            [layerToAdd moveToLayer:page beforeLayer:null];
          }
        }

        // Set the name of the added layer.
        layerToAdd.setName(imageData.name);

        // Select the added layer, which mimicks the
        // behavior of dragged in layers.
        [layerToAdd select:true byExpandingSelection:false];

        break;
    }
    }catch(err){

      //no matter what happened try to unselect the dropped layer
      [droppedLayer select:false byExpandingSelection:false];

      debug(err.name + ": " + err.message);
      logMessage('error', { message: err.name + ": " + err.message, imageData: imageData });


      displayAlert({
        title: 'Error',
        description: 'There was an error while trying to add the item to the document. Contact us at support@invisionapp.com if the problem persists.',
        style: 'error'
      });
    }
  }
}

function setSelectedSegment(segmentedControl, sectionLabel) {
  for (var segmentIdx = 0; segmentIdx < segmentedControl.segmentCount(); segmentIdx++) {
    var segmentLabel = segmentedControl.labelForSegment(segmentIdx);
    if (segmentLabel.isEqualToString(sectionLabel)) {
      [segmentedControl setSelected:true forSegment:segmentIdx];
    } else {
      [segmentedControl setSelected:false forSegment:segmentIdx];
    }
  }
}


function displayPopover(contentString, popoverWidth, targetRect, targetView, edge) {
  var padding = 15;
  var textLabel = NSTextField.new();
  var textWidth = popoverWidth - (padding * 2);

  // Calculate textHeight based on font and textWidth.
  var textStorage = NSTextStorage.new().initWithString(contentString);
  var textContainer = NSTextContainer.alloc().
    initWithContainerSize(NSMakeSize(textWidth, 100000));
  var layoutManager = [[NSLayoutManager alloc] init];
  [layoutManager addTextContainer:textContainer];
  [textStorage addLayoutManager:layoutManager];
  [textStorage addAttribute:NSFontAttributeName value:[textLabel font]
    range:NSMakeRange(0, [textStorage length])];
  var paragraphStyle = NSMutableParagraphStyle.new();
  paragraphStyle.lineSpacing = 2;
  [textStorage addAttribute:NSParagraphStyleAttributeName value:paragraphStyle
    range:NSMakeRange(0, [textStorage length])];
  [textContainer setLineFragmentPadding:0];
  [layoutManager glyphRangeForTextContainer:textContainer];
  var textHeight = [layoutManager usedRectForTextContainer:textContainer].size.height;
  var popoverHeight = textHeight + (padding * 2);

  var view = NSView.alloc().initWithFrame(
    NSMakeRect(0, 0, popoverWidth, popoverHeight)
  );

  textLabel.setFrame(NSMakeRect(padding, padding, textWidth, textHeight));
  textLabel.setStringValue(contentString);
  textLabel.selectable = false;
  textLabel.bordered = false;
  textLabel.drawsBackground = false;
  textLabel.lineBreakMode = NSLineBreakByWordWrapping;
  view.addSubview(textLabel);

  var viewController = NSViewController.new()
  viewController.view = view;

  var popover = NSPopover.new();
  popover.contentViewController = viewController;
  popover.behavior = NSPopoverBehaviorSemitransient;
  popover.contentSize = NSMakeSize(popoverWidth, popoverHeight);

  [popover showRelativeToRect:targetRect ofView:targetView preferredEdge:edge];
  return popover;
}

function displayAlert(options) {
  if (options.optionToNotShowAgain && options.accessoryView) {
    throw new Error('displayAlert: options `accessoryView` and `optionToNotShowAgain` conflict and cannot be used together.');
  }

  const buttons = options.buttons || ['OK'];

  const alert = NSAlert.new();
  alert.setMessageText(options.title);
  if (options.description) {
    alert.setInformativeText(options.description);
  }
  alert.setAlertStyle(options.style == 'error' ? NSCriticalAlertStyle : NSWarningAlertStyle);

  buttons.forEach(function(button) {
    alert.addButtonWithTitle(button);
  });

  if (options.accessoryView) {
    alert.setAccessoryView(options.accessoryView);
  }

  var doNotShowAgainCheckbox;
  const defaultsKey = getKeyName("HasShownAlertFor" + options.optionToNotShowAgain);
  if (options.optionToNotShowAgain) {
    const hasBeenShownBefore =
      NSUserDefaults.standardUserDefaults().boolForKey(defaultsKey);

    if (hasBeenShownBefore) {
      return;
    } else {
      doNotShowAgainCheckbox =
        NSButton.alloc().initWithFrame(NSMakeRect(0, 0, 280, 18));
      doNotShowAgainCheckbox.setButtonType(NSSwitchButton);
      doNotShowAgainCheckbox.setTitle('Do not show this message again');
      alert.setAccessoryView(doNotShowAgainCheckbox);
    }
  }

  const responseCode = alert.runModal();

  // It attempts to prevent the cases where user will acknowldge the message and hit secondary button which is usually cancel
  // so this way acknowledge will happen only if you confirmed the action as well
  if (responseCode == NSAlertFirstButtonReturn && options.optionToNotShowAgain) {
    const shouldNotShowAgain = doNotShowAgainCheckbox.state() == NSOnState;
    if (shouldNotShowAgain) {
      [[NSUserDefaults standardUserDefaults] setObject:true forKey:defaultsKey];
    }
  }

  return responseCode;
}

function displayNamedAlert(alertModalName){
  var expectedModal = eval(alertModalName.toString());
  if (expectedModal){
    return expectedModal();
  }else{
    debug('Something went wrong the expected modal name is invalid: ' + args.alertModalName);
  }
}

function displayPrompt(options) {
  const buttons = options.buttons || ['OK'];

  const alert = NSAlert.new();
  alert.setMessageText(options.title);

  if (options.description) {
    alert.setInformativeText(options.description);
  }

  buttons.forEach(function(button) {
    alert.addButtonWithTitle(button);
  });


  var textField;
  if (options.multiline) {
    textField = NSTextView.alloc().initWithFrame(NSMakeRect(0, 0, 295, 40));
    textField.scrollEnabled = true;
    textField.showsVerticalScrollIndicator= true;
    textField.text = options.defaultText || '';

  } else {
    textField = NSTextField.alloc().initWithFrame(NSMakeRect(0, 0, 295, 22));
    textField.setStringValue(options.defaultText || '');
  }

  textField.setEditable(true);
  alert.setAccessoryView(textField);
  alert.window().setInitialFirstResponder(textField);

  if (alert.runModal() == 1000) {
    var text = (textField.class() == 'NSTextView') ? textField.string() : textField.stringValue();
    return coerceString(text);
  } else {
    return null;
  }
}


function loadReactAppInWebView(plugin, webView, appName, eventHandlers) {
  // Load the local HTML file in the WebView, including the app name in the URL
  // query. We expect the code in index.html to take over at that point,
  // loading the correct app.
  const indexURL = plugin.urlForResourceNamed('Web/index.html');
  var queryString = '?appName=' + appName;
  for (var eventHandler in eventHandlers) {
    queryString += '&nativeHandlers=' + eventHandler;
  }
  const indexURLWithAppQuery =
    NSURL.URLWithString(indexURL.absoluteString() + queryString);
  const request = [NSURLRequest
    requestWithURL:indexURLWithAppQuery
    cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData
    timeoutInterval:60];
  webView.mainFrame().loadRequest(request);

  // We will return a proxy object that can interface with the React app.
  const Proxy = function() {
    this.pendingCallbacks = {};
  };
  Proxy.prototype._resolveAsync = function(id, value) {
    this.pendingCallbacks[id](null, value);
  };
  Proxy.prototype._rejectAsync = function(id, reason) {
    this.pendingCallbacks[id](reason);
  };

  const proxy = new Proxy();

  if (eventHandlers) {
    webView.setUIDelegate(util.createCocoaObject({
      // This is a hack to receive data from the WebView since
      // windowScriptObject doesn’t work in this direction.
      'webView:setStatusText:': function(webView, statusText) {
        if (!statusText || statusText == '') {
          // Empty strings are expected when the view first loads; just ignore it.
          return;
        }
        try {
          var data = JSON.parse(statusText);
        } catch (e) {
          debug("Unable to parse status text \"" + statusText + "\"");
          return;
        }

        // We got some data from the web view. What to do with it?
        if (data.eventType == 'functionCall') {

          const handler = eventHandlers[data.name];
          if (!handler) {
            debug('No native function "' + data.name + '".');

          } else {
            const args = data.args;
            // Try to call the function with the given arguments.
            var result;
            try {
              result = handler.apply(null, args);
            } catch (err) {
              if (data.id) {
                sendDataToWebView(webView, {
                  eventType: 'asyncError',
                  id: data.id,
                  reason: err.message
                });
              }
            }
            if (data.id) {
              sendDataToWebView(webView, {
                eventType: 'asyncResult',
                id: data.id,
                value: result
              });
            }
          }

        } else if (data.eventType == 'asyncResult') {
          proxy._resolveAsync(data.id, data.value);

        } else if (data.eventType == 'asyncError') {
          proxy._rejectAsync(data.id, data.reason);

        } else if (data.eventType == 'initialize') {
          data.functions.forEach(function(func) {
            Proxy.prototype[func] = function(/*arguments*/) {
              debug('Proxy function "' + func + '".');
              const args = Array.prototype.slice.call(arguments);
              const lastArg = args[args.length - 1];
              var asyncID;
              if (lastArg && typeof lastArg == 'function') {
                args.pop();
                asyncID = Math.random().toString(36).substr(2, 10);
                this.pendingCallbacks[asyncID] = lastArg;
              }
              sendDataToWebView(webView, {
                eventType: 'functionCall',
                name: func,
                id: asyncID,
                args: args
              });
            };
          });
          if (eventHandlers.onReady) {
            eventHandlers.onReady();
          }

        } else if (data.eventType == 'debug') {
          debug(data.message);
        }
      }
    }));
  }

  return proxy;
}

function getPreviouslyImportedColors(documentData) {
  return mutableDictionaryForDocumentKey(documentData, 'importedColors')
}

function storeImportedColors(command, documentData, newColors) {
  const allColors = getPreviouslyImportedColors(documentData);
  allColors.addEntriesFromDictionary(newColors);

  // Filter out the colors that don’t appear in this document.
  const documentColors = {};
  $.forEach(documentData.assets().colors(), function(color) {
    const hash = hashForMSColor(color);
    if (allColors[hash]) {
      documentColors[hash] = true;
    }
  });

  [command setValue:documentColors forKey:'importedColors'
    onDocument:documentData];
}

function importColors(command, document, styleData) {
  debug('Importing colors…');
  var assets = document.documentData().assets();

  const previouslyImportedColors =
    getPreviouslyImportedColors(document.documentData());

  var designLibraryColors = [];
  (styleData.globalAssets.colors || []).forEach(function(color){
    designLibraryColors.push(color.value);
  });

  // The new colors to put in the UI. All of them, not just the ones being
  // added now.

  const newColors = NSClassFromString('MSArray')
    ? MSArray.new() // After Sketch 3.9 there is no more MSArray.
    : NSMutableArray.arrayWithCapacity(30);
  const importedColors = {};
  designLibraryColors.forEach(function(colorString) {
    const color = MSColorFromString(colorString);
    const colorHash = hashForMSColor(color);

    // All colors from styleguide should be included in the new colors.
    newColors.addObject(color);

    // Remember the colors that came from the styleguide so we can recognize
    // them later. Serialize color to string in the same we will do it later
    // when getting it from Sketch.
    importedColors[colorHash] = true;
  });

  // Now also include any of the colors that were added by the user and not
  // imported by us.
  $.forEach(assets.colors(), function(existingColor) {
    const hash = hashForMSColor(existingColor);
    if (!previouslyImportedColors[hash]) {
      newColors.addObject(existingColor);
    }
  });

  debug(newColors);
  assets.setColors(newColors);
  storeImportedColors(command, document.documentData(), importedColors);
}


function importTypeStyles(command, document, styleData, onlyExisting) {
  debug('Importing type styles…');

  const currentlyImportedTextStyles = libraryImportedTextStyles(document, styleData);

  (styleData.globalAssets.typeStyles || []).forEach(function(typeStyle) {
    if (!onlyExisting
      || currentlyImportedTextStyles.stylesByMapData[typeStyle._id]
      || currentlyImportedTextStyles.stylesByConsistentId[typeStyle.uuid] ) {
      addOrUpdateSharedTextStyle(document, command, currentlyImportedTextStyles, typeStyle);
    }
  });
}

function importLayerStyles(command, document, styleData, onlyExisting) {
  debug('Importing layer styles…');

  //todo: fix need to take from currently existing as well
  var currentlyImportedSharedStyles = libraryImportedSharedStyles(document, styleData);

  (styleData.globalAssets.sharedStyles || []).forEach(function(sharedStyle) {
    if (!onlyExisting
      || getImportedSharedStyle(currentlyImportedSharedStyles, sharedStyle._id)
      || getImportedSharedStyle(currentlyImportedSharedStyles, sharedStyle.uuid) ) {
      addOrUpdateSharedLayerStyle(document, command, currentlyImportedSharedStyles, sharedStyle);
    }
  });
}

function importImages(command, document, imageType, styleData, onlyExisting, libraryContext) {
  debug('Importing ' + imageType + '...');

  const existingSymbolsMasters = libraryContext.documentSymbols;

  // const category = constants.IMAGE_CATS[imageType];
  (styleData.globalAssets[imageType] || []).forEach(function(image) {
    // Only import layers that are actual Sketch symbols (not regular
    // layers). Note: in the future, we may allow people to override this
    // e.g. for their SVG icons.
    if (image.metadata && image.metadata.sketchSymbolId) {

      //either import all or the symbol existing in the document
      if (!onlyExisting || existingSymbolsMasters[image.metadata.sketchSymbolId]) {
        queueJob(function() {
          const sketchLayerFormat = getSketchLayerFormat(image);
          if (sketchLayerFormat) {
            const pasteboardLayers = loadSketchLayers(sketchLayerFormat.assetKey);
            if (!pasteboardLayers) {
              return;
            }

            libraryContext.pasteboardLayers = pasteboardLayers;

            addOrUpdateSymbolByID(
              command,
              document,
              libraryContext,
              image.metadata.sketchSymbolId
            );
            addOrUpdateOverrideSymbolsForInstance(
              command,
              document,
              libraryContext,
              pasteboardLayers.layers().firstLayer()
            );
          }
        });
      }
    }
  });
}

function getLayersColors(layers) {
  const colorsSet = NSMutableSet.new();
  $.forEach(layers, function(layer) {
    const properties = colorPropertiesForLayer(layer);
    if (properties) {
      properties.forEach(function(property) {
        const color = getColorPropertyOnLayer(layer, property);
        if (color) {
          const hash = hashForMSColor(color);
          colorsSet.addObject(color);
        }
      });
    }
  });
  return colorsSet.allObjects();
}

function updateLayerColor(layer, color, preferBorders) {
  if (layer && layer.class && layer.class() == 'MSLayerGroup') {

    // For groups, recurse through children.
    var anyLayersWereStyled = false;
    $.forEach(layer.layers(), function(childLayer) {
      const anyLocalLayersWereStyled = updateLayerColor(childLayer, color);
      anyLayersWereStyled = anyLayersWereStyled || anyLocalLayersWereStyled;
    });
    return anyLayersWereStyled;

  } else {

    // For non-groups, get the default color property to change, and change it.
    const property = defaultChangeableColorPropertyForLayer(layer, preferBorders);
    if (property) {
      return updateColorPropertyOnLayer(layer, property, color);
    } else {
      return false;
    }
  }
}

function defaultChangeableColorPropertyForLayer(layer, preferBorders) {
  var properties = colorPropertiesForLayer(layer, preferBorders);
  if (properties) {
    properties.sort(function(a, b) {
      return b.weight - a.weight;
    });
    debug(properties);
    return properties[0];
  }
  return;
}

function colorPropertiesForLayer(layer, preferBorders) {
  if (layer && layer.class) {

    const borderPreferenceWeight = preferBorders ? 120 : 0;

    switch (coerceString(layer.class())) {

      case 'MSTextLayer':
        return [
          { property: 'textColor', weight: 5 },
          ...fillColorPropertiesForLayer(layer, 0, function() { return 0; }),
          ...borderColorPropertiesForLayer(layer, 0 + borderPreferenceWeight, function() {
            return 0 + borderPreferenceWeight;
          })
        ];

      case 'MSShapeGroup':
        return [
          ...fillColorPropertiesForLayer(layer, 0, function(fill, fillIdx, fills) {
            var weight = 10;
            if (fill.fillType() == 0) { weight +=   10 }
            if (!fill.isEnabled())    { weight += -100 }
            weight += fillIdx / fills.count();
            return weight;
          }),
          ...borderColorPropertiesForLayer(layer, -10 + borderPreferenceWeight, function(border, borderIdx, borders) {
            var weight = 0 + borderPreferenceWeight;
            if (border.fillType() == 0) { weight +=    2 }
            if (!border.isEnabled())    { weight += -100 }
            weight += Math.min(border.thickness(), 100) / 100;
            weight += borderIdx / borders.count();
            return weight;
          })
        ];
    }
  }
}

function fillColorPropertiesForLayer(layer, newFillWeight, weightForFill) {
  var properties = [];
  $.forEach(layer.style().fills(), function(fill, fillIdx, fills) {
    properties.push({
      property: 'fill',
      weight: weightForFill(fill, fillIdx, fills),
      id: fill.objectID()
    });
  });
  if (properties.length == 0) {
    properties.push({
      property: 'newFill',
      weight: newFillWeight
    });
  }
  return properties;
}

function borderColorPropertiesForLayer(layer, newBorderWeight, weightForBorder) {
  var properties = [];
  $.forEach(layer.style().borders(), function(border, borderIdx, borders) {
    properties.push({
      property: 'border',
      weight: weightForBorder(border, borderIdx, borders),
      id: border.objectID()
    });
  });
  if (properties.length == 0) {
    properties.push({
      property: 'newBorder',
      weight: newBorderWeight
    });
  }
  return properties;
}

function getColorPropertyOnLayer(layer, property) {
  switch (property.property) {
    case 'fill':
      const fill = getStyleById(layer.style().fills(), property.id);
      return fill ? fill.color() : void 0;

    case 'border':
      const border = getStyleById(layer.style().borders(), property.id);
      return border ? border.color() : void 0;

    case 'textColor':
      return layer.textColor();
  }
}

function updateColorPropertyOnLayer(layer, property, newColorString) {
  switch (property.property) {
    case 'fill':
      var fill = getStyleById(layer.style().fills(), property.id);
      if (fill) {
        fill.fillType = 0;
        fill.isEnabled = true;
        fill.color = MSColorFromString(newColorString);
      }
      return true;

    case 'border':
      var border = getStyleById(layer.style().borders(), property.id);
      if (border) {
        border.fillType = 0;
        border.isEnabled = true;
        border.color = MSColorFromString(newColorString);
      }
      return true;

    case 'textColor':
      layer.textColor = MSColorFromString(newColorString).immutableModelObject();
      return true;

    case 'newFill':
      var fill = layer.style().addStylePartOfType(0);
      fill.fillType = 0;
      fill.color = MSColorFromString(newColorString);
      return true;

    case 'newBorder':
      var border = layer.style().addStylePartOfType(1);
      border.fillType = 0;
      border.color = MSColorFromString(newColorString);
      return true;
  }

  return false;
}

function getStyleById(collection, id) {
  return $.find(collection, function(style) {
    return style.objectID().isEqualToString(id);
  });
}

function getParentLayer(layer, parentClass) {
  // Default to any MSLayer.
  parentClass = parentClass || MSLayer;

  return $.find(layer.ancestors().reverseObjectEnumerator().allObjects(), function(ancestor) {
    // Some versions of Sketch return ancestors() with the layer itself in the
    // list of ancestors, so we have to check that the ancestor is not the
    // input layer.
    return ancestor.class().isSubclassOfClass(parentClass) &&
      ancestor !== layer;
  });
}

function applyToAllImages(styleData, func) {

  for (var imageType in constants.IMAGE_CATS) {
    //filtering them out for now as user of this method did not planned on sketchSymbols to be present
    if (imageType === 'sketchSymbols'){
      return;
    }
    if (styleData.globalAssets[imageType]) {
      styleData.globalAssets[imageType].forEach(function(image) {
        func(image, imageType, image.sectionId);
      });
    }
  }
}


//represents the opacity and the blending of the MSLayer
function sketchContextSettingsFromBrandAIObject(brandaiObject) {

  var contextSettings = MSGraphicsContextSettings.new();
  if (brandaiObject.opacity) {
    contextSettings.setOpacity(brandaiObject.opacity);
  }
  return contextSettings;
}

function sketchStyleFromBrandAISharedStyle(sharedStyle) {
  const data = dataFromWebCustomCache(sharedStyle.sketchArchiveAssetKey);
  const immutableStyle = archive.sketchObjectFromArchiveData(data);
  return mutableSketchObject(immutableStyle);
}


function brandAISharedStyleFromSketchSharedStyle(sharedStyle) {
  return {
    objectID: sharedStyle.objectID(),
    name: sharedStyle.name()
  };
}

// MSPasteboardLayers is an object that Sketch uses to paste layers into a
// document. This function constructs a new MSPasteboardLayers from just a
// MSSymbolMaster. This mimics the user having copied an instance of that
// master to the pasteboard.
function pasteboardLayersFromSymbolMaster(symbolMaster) {
  const pboardLayers = MSPasteboardLayers.new();
  const symbols = NSMutableDictionary.dictionaryWithCapacity(1);
  [symbols setObject:symbolMaster forKey:(symbolMaster.symbolID())];
  // In Sketch 48, the method name changed from symbols() to localSymbols().
  (pboardLayers.setLocalSymbols || pboardLayers.setSymbols)(symbols);
  pboardLayers.setLayers(MSLayerArray.arrayWithLayer(
    symbolMaster.newSymbolInstance()
  ));
  return pboardLayers;
}

function isImmutableSketchObject(sketchObject) {
  return !!(
    sketchObject &&
    sketchObject.class().mutableClass &&
    sketchObject.class().mutableClass() &&
    sketchObject.class().mutableClass() !== sketchObject.class()
  );
}

function mutableSketchObject(immutableSketchObject) {
  if (immutableSketchObject && immutableSketchObject.class) {
    const immutableClass = immutableSketchObject.class();
    if (immutableClass.mutableClass) {
      const mutableClass = immutableClass.mutableClass();
      return mutableClass.new().initWithImmutableModelObject(
        immutableSketchObject
      );
    }
  }
}

// Convert any immutable Sketch objects to mutable.
function arrayWithMutableSketchObjects(array) {
  return $.map(array, function(object) {
    if (isImmutableSketchObject(object)) {
      return mutableSketchObject(object);
    } else {
      return object;
    }
  });
}

// Convert any immutable Sketch objects to mutable.
function dictionaryWithMutableSketchObjects(dictionary) {
  return $.mapObject(dictionary.allKeys(), function(key) {
    const object = dictionary.objectForKey(key);
    if (object.class().dictionary) {
      return [key, dictionaryWithMutableSketchObjects(object)];
    } else if (isImmutableSketchObject(object)) {
      return [key, mutableSketchObject(object)];
    } else {
      return [key, object];
    }
  });
}

function loadSketchLayers(assetKey) {
  const data = dataFromWebCustomCache(assetKey);

  debug('Unarchiving data...');
  const object = archive.sketchObjectFromArchiveData(data);

  if (object) {
    if (object.class().dictionary) {
      debug('...data is a dictionary');

      const pasteboardLayers = MSPasteboardLayers.new();

      pasteboardLayers.setLayers(
        MSLayerArray.arrayWithLayers(
          arrayWithMutableSketchObjects(
            archive.sketchObjectFromArchiveData(
              object.objectForKey('layers')
            )
          )
        )
      );

      // In Sketch 48, the method name changed from symbols() to localSymbols().
      (pasteboardLayers.setLocalSymbols || pasteboardLayers.setSymbols)(
        dictionaryWithMutableSketchObjects(
          archive.sketchObjectFromArchiveData(
            object.objectForKey('symbols')
          )
        )
      );

      //todo: need to understand if this need to change
      const sharedObjects = object.objectForKey('sharedObjects');

      if (sharedObjects) {
        pasteboardLayers.setSharedObjects(
          dictionaryWithMutableSketchObjects(
            sharedObjects
          )
        );
      }

      return pasteboardLayers;

    } else {
      debug('...data is NOT a dictionary, assume it is layers');
      const layer = mutableSketchObject(object);
      layer.setObjectID(null);
      if (layer.class() == 'MSSymbolMaster') {
        // Symbol masters are a special case because what we want to “paste” is
        // an instance of the master, not the master itself.
        return pasteboardLayersFromSymbolMaster(layer);
      } else {

        const pasteboardLayers = MSPasteboardLayers.new();
        pasteboardLayers.setLayers(
          MSLayerArray.arrayWithLayers(
            [layer]
          )
        );
        return pasteboardLayers;
      }
    }
  } else {
    debug('Could not unarchive object data for url ' + assetKey);
  }
}

function symbolMasterFromPasteboardLayers(pasteboardLayers) {
  // Assume there is one layer.
  const layer = pasteboardLayers.layers().firstLayer();

  if (layer) {

    // If the layer is a master, then we are done!
    if (layer.className() == 'MSSymbolMaster') {
      return layer;

    // If the layer is an instance, then look for a master in the attached symbols.
    } else if (layer.className() == 'MSSymbolInstance') {
      // In Sketch 48, the method name changed from symbols() to localSymbols().
      const symbols = (pasteboardLayers.localSymbols || pasteboardLayers.symbols)();
      if (symbols && symbols.count && symbols.count())
      // Get the symbol master corresponding to the instance.
      return symbols.objectForKey(layer.symbolID());
    }

  }
}

function importImage(assetKey, fileExt) {
  var importer;

  switch (fileExt) {
    case 'svg':
      importer = MSSVGImporter.new();
      break;

    case 'eps':
    case 'ai':
      importer = MSPDFImporter.epsImporter();
      break;
    case 'jpg':
    case 'jpeg':
    case 'png':
      importer = new BitmapImporter();
      break;
  }

  if (importer) {
    var data = dataFromWebCustomCache(assetKey);
    if (data) {
    importer.prepareToImportFromData(data);
    return importer.importAsLayer();
    }
    return null;
  } else {
    debug("No importer for image with \"" + fileExt + "\" extension");
    return null;
  }
}

function dataFromWebCustomCache(urlString) {
  var imgData;
  const webView = persist.get('dsmMainWebView');

  if (webView) {
    var cached = webView.windowScriptObject().evaluateWebScript(
      "window.dsm['imageCache-" + urlString + "']"
    );
    if (cached.class() != WebUndefined) {
      debug("Loading image data from custom web cache (" + urlString + ")");
      imgData = NSData.dataWithContentsOfURL(NSURL.URLWithString(cached));
    }
  }

  if (!imgData) {
    debug('Did not find the url in the custom web cache. url:' + urlString);
    logMessage('error', {message: 'Did not find the url in the custom web cache.', url: urlString });
  }

  return imgData;
}

function dataFromURL(urlString) {
  var imgData;
  const url = NSURL.URLWithString(urlString);
  const webView = persist.get('dsmMainWebView');

  if (webView) {
    var resource = webView.mainFrame().dataSource().subresourceForURL(url);
    if (resource) {
      debug("Loading image data from web view data source (" + urlString + ")");
      imgData = resource.data();
    }
  }

  if (!imgData) {
    debug('Did not find the url in the web resource cache. url:' + urlString);
    logMessage('error', {message: 'Did not find the url in the web resource cache.', url: urlString });
  }

  return imgData;
}

function importPNG(nib, urlString) {
  var url = NSURL.URLWithString(urlString);

  // Try to get the image data from the web view, where it is probably already loaded.
  var resource = nib.mainWebView.mainFrame().dataSource().subresourceForURL(url);
  var image;
  if (resource) {
    debug('load ' + urlString + ' from web view');
    image = NSImage.alloc().initWithData(resource.data());
  } else {
    debug('load ' + urlString + ' from network');
    image = NSImage.alloc().initWithContentsOfURL(url);
  }
  var imageLayer = [MSBitmapLayer bitmapLayerFromImage:image withSizeScaledDownByFactor:1];
  var group = MSLayerGroup.new()
  group.addLayers([imageLayer]);
  group.resizeToFitChildrenWithOption(0);
  return group;
}

//get symbol master for specific symbol
function getSymbolMasterByID(document, symbolID, libraryContext) {
  if (!libraryContext.documentSymbols) {
	  libraryContext.documentSymbols = util.getSymbolsMastersByID(document);
  }
 return libraryContext.documentSymbols[symbolID];
}

function sizeKeyForLayer(layer) {
  return layer.bounds().size.width + 'X' + layer.bounds().size.height;
}

function symbolMastersBySizeInDocument(document) {
  const symbols = document.documentData().allSymbols();
  const bySize = {};
  $.forEach(symbols, function(symbol) {
    const size = sizeKeyForLayer(symbol);
    bySize[size] = bySize[size] || [];
    bySize[size].push(symbol);
  });
  return bySize;
}


function updateInstancesOfSharedLayerStyle(command, document, previousSharedObjectID, newSharedStyle) {

  const classes = [MSShapeGroup]; //todo: discuss MSLayerGroup
  updateInstancesOfLayerStyle(document, classes, previousSharedObjectID, newSharedStyle, function(layer){
    layer.setStyle(newSharedStyle.style().copy());
  });

  markSharedLayerAsProcessed(command, document, previousSharedObjectID, newSharedStyle.style().sharedObjectID());
}

function updateInstancesOfTextLayerStyle(command, document, previousSharedObjectID, newSharedTextStyle) {
  const classes = [MSTextLayer];
  updateInstancesOfLayerStyle(document, classes, previousSharedObjectID, newSharedTextStyle, function(layer){
    layer.style().setTextStyle(newSharedTextStyle.style().textStyle());
  });

  markTextLayerAsProcessed(command, document, previousSharedObjectID, newSharedTextStyle.style().sharedObjectID());
}

/**

 Update all the instanced of shared layers/ text layers whose id was update to the new consistent id
 - find them in all document pages
 - set the new consistent shared object id
 - update their style by calling the provided callback

 */
function updateInstancesOfLayerStyle(document, classes, previousSharedObjectID, newStyle, updateStyleCB) {

  if (previousSharedObjectID.isEqualToString(newStyle.style().sharedObjectID())) { //todo: this one or the processed map verification?
    return;
  }

  debug('Updating layers of style that was re-imported with consistent id, previousId: ' + previousSharedObjectID + 'new sharedStyle: ' + newStyle);
  const newSharedObjectID = newStyle.style().sharedObjectID();

  for (var pageIndex = 0; pageIndex < document.pages().count(); pageIndex++) {
    const page = document.pages().objectAtIndex(pageIndex);
    const layerStyles = descendantLayersWithClassNames(page, classes);

    for (var layerIndex = 0; layerIndex < layerStyles.count(); layerIndex++) {
      var layer = layerStyles[layerIndex];
      const sharedStyleID = layer.style() && layer.style().sharedObjectID();
      if (sharedStyleID && sharedStyleID.isEqualToString(previousSharedObjectID)) {

        updateStyleCB(layer);
        layer.style().setSharedObjectID(newSharedObjectID);
      }
    }
  }
}


function descendantLayersWithClassNames(layer, classes) {
  const predicateString = classes.map(function(c) {
    return 'className == "' + c + '"';
  }).join(' || ');
  const predicate = NSPredicate.predicateWithFormat(predicateString);
  return layer.children().filteredArrayUsingPredicate(predicate);
}

function createLibraryContext(pasteboardLayers, document) {

  var styleData = persist.get('dsmStyleData');
  return {
    pasteboardLayers: pasteboardLayers,
    librarySymbols: allLibrarySymbolsIndexedBySymbolID(styleData),
    librarySymbolsBySize: allLibrarySymbolsIndexedBySize(styleData),
    libraryImportedSharedStyles: libraryImportedSharedStyles(document, styleData),
    libraryImportedTextStyles: libraryImportedTextStyles(document, styleData),
    allLibrarySharedStyles: allLibrarySharedStylesByUUID(styleData),
    allLibraryTextStyles: allLibraryTextStylesByUUID(styleData)
  };
}

function addOrUpdateSymbol(command, document, libraryContext, symbolMaster, imageData) {
  imageData = imageData || {};

  const symbolID = symbolMaster.symbolID();

  const symbolMasterInDocument = getSymbolMasterByID(document, symbolID, libraryContext);

  if (symbolMasterInDocument) {
    debug('Updating symbol with symbolID: ' + symbolID);

    // Replace layers.
    replaceGroupContents(symbolMasterInDocument, symbolMaster);

    // Copy properties from saved master.
    symbolMasterInDocument.setBackgroundColor(
      symbolMaster.backgroundColor()
    );
    symbolMasterInDocument.setIncludeBackgroundColorInInstance(
      symbolMaster.includeBackgroundColorInInstance()
    );
    symbolMasterInDocument.setIncludeBackgroundColorInExport(
      symbolMaster.includeBackgroundColorInExport()
    );
    symbolMasterInDocument.setHasBackgroundColor(
      symbolMaster.hasBackgroundColor()
    );

    //adding this condition will stop it from failing in Sketch 43
    if (symbolMaster.resizesContent) {
      symbolMasterInDocument.setResizesContent(
        symbolMaster.resizesContent()
      );
    }
    symbolMasterInDocument.setIncludeInCloudUpload(
      symbolMaster.includeInCloudUpload()
    );
    symbolMasterInDocument.setExportOptions(
      symbolMaster.exportOptions()
    );


    symbolMasterInDocument.frame().setWidth(symbolMaster.frame().width());
    symbolMasterInDocument.frame().setHeight(symbolMaster.frame().height());

    // Override properties from design library.
    if (imageData.name) {
      symbolMasterInDocument.setName(imageData.name);
    }

  } else {
    debug('Adding symbol with symbolID: ' + symbolID);

    // Create symbols page if it doesn’t exist.
    const symbolsPage = document.documentData()
      .symbolsPageOrCreateIfNecessary();

    // Add master to symbols page.
    symbolsPage.addLayers([symbolMaster]);

    // Move the out of the way so we can calculate a good position.
    symbolMaster.frame().setX(-9999);
    symbolMaster.frame().setY(-9999);

    // This method on MSLayerPaster changed from a class
    // method to an instance method in Sketch 48.
    const layerPaster = MSLayerPaster.findFirstAvailablePositionForSize_nextToArtboardsOnPage_inAllowedRect ?
      MSLayerPaster : MSLayerPaster.new()

    // Find a good location on the symbols page. Where would Sketch put it?
    const position = [layerPaster
      findFirstAvailablePositionForSize:(symbolMaster.frame().size)
      nextToArtboardsOnPage:symbolsPage
      inAllowedRect:CGRectMake(0, 0, 1000, 1000)];

    // Move the master into position.
    symbolMaster.frame().setX(position.x);
    symbolMaster.frame().setY(position.y);

    // Override properties from design library.
    if (imageData.name) {
      symbolMaster.setName(imageData.name);
    }

	  libraryContext.documentSymbols[symbolID] = symbolMaster;
  }

  updateSharedObjectsForLayerTree(command, document, libraryContext, symbolMaster, false, imageData);
}

function addOrUpdateSymbolByID(command, document, libraryContext, symbolID) {
  if (itemHasAlreadyBeenImportedThisSession(symbolID)) {
    //debug('Skipping already imported symbol with symbolID: ' + symbolID);
    return;
  }

  const symbolData = libraryContext.librarySymbols[symbolID];
  if (symbolData) {
    debug('Found symbol in library');
    // The symbol exists in the library, so we should use that one.
    const sketchLayerFormat = getSketchLayerFormat(symbolData.image);
    if (sketchLayerFormat) {

	    var sketchLayers = loadSketchLayers(sketchLayerFormat.assetKey);
	    if (!sketchLayers){
		    debug(
			    'Not adding or updating symbol "' +
			    symbolData.image.name +
			    '": could not load its sketch layer data.'
		    );
	      return;
      }
      const symbolMaster = symbolMasterFromPasteboardLayers(
	      sketchLayers
      );
      if (symbolMaster) {
        addOrUpdateSymbol(
          command,
          document,
          libraryContext,
          symbolMaster,
          symbolData.image
        );
      } else {
        debug(
          'Not adding or updating symbol "' +
          symbolData.image.name +
          '": pasteboard layers do not represent a symbol (in add or update).'
        );
      }
    }

  } else {
    debug('Looking for symbol in attached layers');
    // The symbol is not present in the design library,
    // so use the one in the MSPasteboardLayers “attachments.”
    const attachedSymbols = (
      // In Sketch 48, the method name changed from symbols() to localSymbols()
      libraryContext.pasteboardLayers.localSymbols ||
      libraryContext.pasteboardLayers.symbols
    )();
    if (attachedSymbols) {
      const symbolMaster = attachedSymbols.objectForKey(symbolID);

      if (symbolMaster) {
        debug('Found symbol in attached layers');
        addOrUpdateSymbol(
          command,
          document,
          libraryContext,
          symbolMaster
        );
      } else {
        debug('Not adding symbol; no master found for symbolID ' + symbolID);
      }

    } else {
      debug('Not adding symbol; no attached symbols when looking for symbolID ' + symbolID);
    }
  }
}

function addOrUpdateSharedTextStyle(document, command, libraryImportedTextStyles, typeStyle) {
  const textStyleByConsistentId = getImportedTextStyle(libraryImportedTextStyles, typeStyle.uuid);

  if (itemHasAlreadyBeenImportedThisSession(typeStyle._id)) {
    debug('Skipping already imported type style with _id: ' + typeStyle._id);
    return textStyleByConsistentId;
  }

  const desiredTextStyle = sketchTextStyleFromLibraryTypeStyle(typeStyle);
  const desiredContextSettings = sketchContextSettingsFromBrandAIObject(typeStyle);

  if (textStyleByConsistentId) {

    return updateSharedTextStyle(
      document,
      textStyleByConsistentId,
      desiredTextStyle,
      desiredContextSettings,
      typeStyle.name
    );

  } else {

    // There is no style in Sketch that corresponds to the
    // one from the API. So we want to add that style.
    const addedTextStyle = addSharedTextStyle(
      command,
      document,
      desiredTextStyle,
      desiredContextSettings,
      typeStyle,
      libraryImportedTextStyles
    );


    return addedTextStyle;
  }
}

function updateSharedTextStyle(document, currentTextStyle, newTextStyle, newContextSettings, name) {
  debug('Updating shared text style: ' + name);
  name = name || 'Untitled Style';

  // Update the name.
  currentTextStyle.setName(name);

  // Create a dummy layer and add to the document. This
  // will be the source that the shared style is updated to
  // match.
  const dummyLayer = MSTextLayer.new();
  const dummyStyle = dummyLayer.style();
  dummyStyle.setTextStyle(newTextStyle);
  dummyStyle.setContextSettings(newContextSettings);
  dummyStyle.setSharedObjectID(currentTextStyle.objectID());

  if (NSClassFromString('MSShareableObjectUpdater')) {
    // For Sketch >= 50:

    // Connect the shape to the current document, so that the updater can look
    // up the shared style it uses.
    dummyLayer.setDocumentData(document.documentData());

    // Use MSShareableObjectUpdater to sync the style of the source shape to the
    // shared style it uses. This is the class used by MSSyncLocalStyleAction
    // internally.
    const updater = MSShareableObjectUpdater.new();
    updater.setSelectedLayers(MSLayerArray.arrayWithLayer(dummyLayer));
    updater.performSyncAndOrUnlinkAction();

  } else {
    // For Sketch < 50:
    document
      .documentData()
      .layerTextStyles()
      .syncSharedObjectWithInstance(dummyStyle);
  }

  return currentTextStyle;
}

function addSharedTextStyle(command, document, desiredTextStyle, desiredContextSettings, typeStyle, libraryImportedTextStyles) {
  debug('Adding new shared text style: ' + typeStyle.name);
  const name = typeStyle.name || 'Untitled Style';

  const newStyle = MSStyle.alloc().init();
  newStyle.setTextStyle(desiredTextStyle);
  newStyle.setContextSettings(desiredContextSettings); //will set the opacity

  //set the styleMode on the sharedStyle instance, previous add method have created sharedStyle object from the passed style
  // but the current addSharedObject method does not
  const sharedStyle = MSSharedStyle.new();
  sharedStyle.setValue(newStyle);

  sharedStyle.setName(name); //update the name

  // setting the sharedObjectId on the new style so that all styles created but the plugin will have the same consistent id
  // in the future when we might assume all the uploaded layers were uploaded with consistent id we can stop setting it manually
  sharedStyle.setObjectID(typeStyle.uuid);
  sharedStyle.style().setSharedObjectID(typeStyle.uuid);


  const sketchTextStylesContainer = document.documentData().layerTextStyles();

  //add new sharedStyle with the added text style data
  sketchTextStylesContainer.addSharedObject(sharedStyle);

  // As the addSharedObject method does not return the added style we need to find it manually.
  // Since it was added at the end we just use the length to find its place
  var allTextStyles = sketchTextStylesContainer.objects();
  const addedTextStyle = allTextStyles[allTextStyles.length - 1];

  try {
    // while transitioning to the consistent id we might still have layers that were using the previous sharedTextStyle
    // find and update those layers and remove the old text style
    const previouslyImportedTextLayerStyle = getImportedTextStyle(libraryImportedTextStyles, typeStyle._id);
    if (previouslyImportedTextLayerStyle) {
      updateInstancesOfTextLayerStyle(command, document, previouslyImportedTextLayerStyle.style().sharedObjectID(), addedTextStyle);
      sketchTextStylesContainer.removeSharedObject(previouslyImportedTextLayerStyle);
    }
    //add the newly added style to the imported styles map
    addNewImportedTextStyle(libraryImportedTextStyles, addedTextStyle);
  } catch (err) {

    //remove the added style so that we will try to re-add once again and update its layers, otherwise we will not get into this flow again
    sketchTextStylesContainer.removeSharedObject(addedTextStyle);

    //log a message
    debug(err);
    logMessage('error', { message: 'Failed to update associated text layers ' + err.name + ": " + err.message });

    throw err; //we want to fail this step from further completion
  }

  return addedTextStyle;
}


function addOrUpdateSharedLayerStyle(document, command, libraryImportedSharedStyles, sharedStyle) {

  const sharedStyleByConsistentId = getImportedSharedStyle(libraryImportedSharedStyles, sharedStyle.uuid);

  if (itemHasAlreadyBeenImportedThisSession(sharedStyle._id)) {
    debug('Skipping already imported shared style with _id: ' + sharedStyle._id);
    return sharedStyleByConsistentId;
  }

  const desiredStyle = sketchStyleFromBrandAISharedStyle(sharedStyle);
  if (!desiredStyle){
    debug('Not adding or updating shared style "' + sharedStyle.name + '": could not load its sketch layer data.');
    return;
  }

  if (sharedStyleByConsistentId) {
    debug('Updating shared layer style: ' + sharedStyle.name + ' ' + sharedStyle.uuid);
    sharedStyleByConsistentId.setName(sharedStyle.name);

    // Create a dummy shape group from which to take the style.
    const dummyLayer = MSShapeGroup.new();
    desiredStyle.style().copyPropertiesToObject_options(dummyLayer.style(), null);
    dummyLayer.style().setSharedObjectID(sharedStyleByConsistentId.objectID());

    if (NSClassFromString('MSShareableObjectUpdater')) {
      // For Sketch >= 50:

      // Connect the shape to the current document, so that the updater can look
      // up the shared style it uses.
      dummyLayer.setDocumentData(document.documentData());

      // Use MSShareableObjectUpdater to sync the style of the source shape to
      // the shared style it uses. This is the class used by
      // MSSyncLocalStyleAction internally.
      const updater = MSShareableObjectUpdater.new();
      updater.setSelectedLayers(MSLayerArray.arrayWithLayer(dummyLayer));
      updater.performSyncAndOrUnlinkAction();

    } else {
      // For Sketch < 50:

      // Save users’s current selection.
      const userSelection = document.selectedLayers();

      // Create a layer on the current page to sync from.
      document.currentPage().addLayers([dummyLayer]);

      // Sync styles from the layer to the shared style, as
      // if the user had clicked the sync button in Sketch.
      dummyLayer.select_byExpandingSelection(true, false);
      const syncAction = MSSyncSharedStyleAction.alloc().initWithDocument(document);
      syncAction.doPerformAction(null);

      // Remove added layer and restore user’s selection.
      document.currentPage().removeLayer(dummyLayer);
      document.setSelectedLayers(userSelection);
    }

    return sharedStyleByConsistentId;

  } else {
    var name = sharedStyle.name || 'Untitled Style';
    debug('Adding shared layer style: ' + name + ' ' + sharedStyle.uuid);
    const sketchLayerStylesContainer = document.documentData().layerStyles();

    desiredStyle.setName(name);

    // setting the sharedObjectId on the new style so that all styles created but the plugin will have the same consistent id
    // in the future when we might assume all the uploaded layers were uploaded with consistent id we can stop setting it manually
    desiredStyle.setObjectID(sharedStyle.uuid);
    desiredStyle.style().setSharedObjectID(sharedStyle.uuid);

    //add new sharedStyle
    sketchLayerStylesContainer.addSharedObject(desiredStyle);


    // As the addSharedObject method does not return the added style we need to find it manually.
    // Since it was added at the end we just use the length to find its place
    var sharedStyles = sketchLayerStylesContainer.objects();
    const addedSharedStyle = sharedStyles[sharedStyles.length - 1];

    try {
      // while transitioning to the consistent id we might still have layers that were using the previous sharedStyle
      // find and update those layers and remove the old shared style
      const previouslyImportedSharedLayerStyle = getImportedSharedStyle(libraryImportedSharedStyles, sharedStyle._id);
      if (previouslyImportedSharedLayerStyle) {
        updateInstancesOfSharedLayerStyle(command, document, previouslyImportedSharedLayerStyle.style().sharedObjectID(), addedSharedStyle);
        sketchLayerStylesContainer.removeSharedObject(previouslyImportedSharedLayerStyle);
      }

      //add the newly added style to the imported styles map
      addNewImportedSharedStyle(libraryImportedSharedStyles, addedSharedStyle);
    }catch (err){
      //remove the added style so that we will try to re-add once again and update its layers, otherwise we will not get into this flow again
      sketchLayerStylesContainer.removeSharedObject(addedSharedStyle);

      //log a message
      debug(err);
      logMessage('error', { message: 'Failed to update associated shared layers ' + err.name + ": " + err.message });

      throw err; //we want to fail this step from further completion
    }

    return addedSharedStyle;
  }
}

function updateSharedObjectsForLayerTree(command, document, libraryContext, layerTreeRoot, isFirstLevel, imageData) {
  debug('Update shared objects and nested symbols for layer: ' + layerTreeRoot + (layerTreeRoot.symbolID ? ' with symbolID: ' + layerTreeRoot.symbolID() : '') );

  const filteredDescendantLayers = descendantLayersWithClassNames(
    layerTreeRoot, [MSTextLayer, MSShapeGroup, MSSymbolInstance]
  );

  //assign to a variable so that we have a correct pointer to the specific image data even if in library.resolvedSharedObjects will
  var resolvedSharedObjects = getResolvedSharedObjects(imageData);

  $.forEach(filteredDescendantLayers, function(descendant) {
    const sharedObjectID = descendant.style().sharedObjectID();

    if (descendant.className() == 'MSTextLayer') {
      // Fixes a bug where the archive/unarchive process does not preserve the
      // correct value for line spacing behavior. We assume that 2 is the
      // correct value.
      if (descendant.lineSpacingBehaviour() == 0) {
        descendant.setLineSpacingBehaviour(2);
      }

      const typeStyle = resolvedSharedObjects[sharedObjectID] || libraryContext.allLibraryTextStyles[sharedObjectID];

      // Should be using a Brand.ai type style.
      if (typeStyle) {
        // Import the shared text style to the document.
        const correctTextStyle =
          addOrUpdateSharedTextStyle(document, command, libraryContext.libraryImportedTextStyles, typeStyle);

        // Update the layer to reflect the current shared state.
        descendant.style().setTextStyle(correctTextStyle.style().textStyle());

        // Link to the correct shared text style.
        descendant.style().setSharedObjectID(correctTextStyle.objectID());
      }


    } else if (descendant.className() == 'MSShapeGroup') {

      var sharedStyle = resolvedSharedObjects[sharedObjectID] || libraryContext.allLibrarySharedStyles[sharedObjectID];

      // Should be using a Brand.ai shared style.
      if (sharedStyle) {
        const correctLayerStyle =
          addOrUpdateSharedLayerStyle(document, command, libraryContext.libraryImportedSharedStyles, sharedStyle);

        // Update the layer to reflect the current shared state.
        descendant.setStyle(correctLayerStyle.style().copy());

        // Link the layer to the shared style.
        descendant.style().setSharedObjectID(correctLayerStyle.objectID());
      }


    } else if (descendant.className() == 'MSSymbolInstance') {
      const symbolID = descendant.symbolID();
      debug('Descendant symbol instance ' + descendant + ' with symbolID: ' + symbolID);

      addOrUpdateSymbolByID(
        command,
        document,
        libraryContext,
        symbolID
      );

      // Apart from importing the correct symbol master to back the instance,
      // we also should import any masters that are referred to by the instance
      // overrides. A user can override a nested symbol with another and if
      // they have, we want that symbol to also be added to the document.
      addOrUpdateOverrideSymbolsForInstance(
        command,
        document,
        libraryContext,
        descendant
      );

      // Import symbols that are the same size as the *master*. Sketch offers
      // these as possible overrides so we want to make sure they are present in
      // the document so Sketch can do this.
      processSameSizeSymbolsForInstance(command,
        document,
        libraryContext,
        symbolID,
        isFirstLevel
      );
    }

  });
}

function addOrUpdateOverrideSymbolsForInstance(command, document, libraryContext, symbolInstance) {
  if (symbolInstance && symbolInstance.class().isSubclassOfClass(MSSymbolInstance)) {

    // Import any symbols that are explicitly used as overrides. Note that
    // there are cases when this might not qualify under the
    // symbols-of-same-size check. E.g. the overriden symbol no longer matches
    // the size of the original.
    var overrides = symbolInstance.overrides();
    if (overrides) {
      const zeroKeyOverrides = overrides.objectForKey(0);
      if (zeroKeyOverrides) {
        overrides = zeroKeyOverrides;
      }
      if (overrides && overrides.allKeys) {
        $.forEach(overrides.allKeys(), function(key) {
          const override = overrides[key];
          if (override && override.objectForKey && override.objectForKey('symbolID')) {
            debug('Will update overrrides for symbol instance ' + symbolInstance + ' ' + override.objectForKey('symbolID'));
            addOrUpdateSymbolByID(
              command,
              document,
              libraryContext,
              override.objectForKey('symbolID')
            );
          }
        });
      }
    }
  }
}

function processSameSizeSymbolsForInstance(command, document, libraryContext, symbolID, isFirstLevel){
  const symbolMaster = libraryContext.librarySymbols[symbolID];
  if (!isFirstLevel && symbolMaster && symbolMaster.image && symbolMaster.image.dimensions) {

    const processedDimension = symbolMaster.image.dimensions;
    const symbolsOfSameSize = libraryContext.librarySymbolsBySize[processedDimension];

    //after retrieving the list of all the symbols for this dimensions we mark it as processed (going through it again showed very negative effect on performance in certain scenarios)
    if (symbolsOfSameSize && !itemHasAlreadyBeenImportedThisSession(processedDimension)) {
      debug('Processing same size items for symbolID: ' + symbolID + 'name: ' + symbolMaster.image.name + ' with dimension: ' + processedDimension)
      symbolsOfSameSize.forEach(function(symbolOfSameSize) {
        addOrUpdateSymbolByID(
          command,
          document,
          libraryContext,
          symbolOfSameSize.metadata.sketchSymbolId
        );
      });
    }
  }
}

function getSketchLayerFormat(image) {
  var result = null;

  if (image && image.additionalFormats && image.additionalFormats.find) {
    result = image.additionalFormats.find(function(format) {
      return format && format.extension == 'skla';
    });
  }

  // fallback for some old data that doesn't contain additionalFormats:
  return result || { url: image.url.replace(/\.svg$/, '.skla'), extension: 'skla' };
}

function getPageByName(document, pageName) {
  return $.find(document.pages(), function(page) {
    return page.name() == pageName;
  });
}

function replaceGroupContents(existingGroup, newGroup) {
  // Remove existing layers in group.
  while (existingGroup.layers().count() > 0) {
    existingGroup.removeLayer(existingGroup.lastLayer());
  }
  existingGroup.addLayers(newGroup.layers());
}

function mutableDictionaryForDocumentKey(documentData, key) {
  const obj = ((documentData.userInfo() || {})[IDENTIFIER] || {})[key];
  return NSMutableDictionary.dictionaryWithDictionary(obj || {});
}


// Add a view in front of the web view that will accept the first mouse event
// when the window is not active and forward that event to the webview. This
// simulates implementing -acceptsFirstMouse: on the WebView, but subclassing
// that to do so does not work.
function addFirstMouseAcceptor(nib) {
  const contentView = nib.mainWindow.contentView();
  const webView = nib.mainWebView;

  // Look for a view already added by this function. If it’s already there we
  // are done.
  const existingAcceptor = $.find(contentView.subviews(), function(view) {
    return view.identifier() == 'firstMouseAcceptor';
  });
  if (existingAcceptor) {
    return;
  }

  // NSButton already returns YES for -acceptsFirstMouse: so all we need to do
  // is handle the mouseDown event.
  const button = util.createCocoaObject({
    'mouseDown:': function(evt) {
      // Remove this view. Subsequent events such the mouseUp event that will
      // probably immediately follow mouseDown or any other mouse events will
      // be handled as if this view is not here because it will not be here!
      this.removeFromSuperview();

      // Now send the same mouseDown event again as if the user had just
      // clicked. With the button gone, this will be handled by the WebView.
      NSApplication.sharedApplication().sendEvent(evt);
    },
  }, NSButton);

  button.setIdentifier('firstMouseAcceptor');
  button.setTransparent(true);
  button.setTranslatesAutoresizingMaskIntoConstraints(false);

  contentView.addSubview(button);

  const views = {
    button: button,
    webView: webView
  };

  // Match width of WebView.
  contentView.addConstraints([NSLayoutConstraint
    constraintsWithVisualFormat:'H:[button(==webView)]'
    options:NSLayoutFormatDirectionLeadingToTrailing
    metrics:null
    views:views]);

  // Match height of WebView.
  contentView.addConstraints([NSLayoutConstraint
    constraintsWithVisualFormat:'V:[button(==webView)]'
    options:NSLayoutFormatDirectionLeadingToTrailing
    metrics:null
    views:views]);

  // Match top of WebView.
  contentView.addConstraints([[NSLayoutConstraint
    constraintWithItem:button attribute:NSLayoutAttributeTop
    relatedBy:NSLayoutRelationEqual toItem:webView
    attribute:NSLayoutAttributeTop multiplier:1 constant:0]]);
}

function flippedPointInView(view, x, y) {
  return NSMakePoint(x + view.frame().origin.x, view.frame().size.height + view.frame().origin.y - y);
}

// Returns a new rect where the height has been changed,
// maintaining the y position of the overall rect relative
// to the top of the screen.
function resizeFrameToNewHeightExpandingDown(nib, rect, newHeight, newWidth) {
  const heightIncrease = newHeight - rect.size.height;

  var newRect = CGRectMake(
    rect.origin.x,                  // Keep current x
    rect.origin.y - heightIncrease, // Calculate new y so rect expands down instead of up
    (newWidth || rect.size.width),  // Keep existing width
    newHeight                       // Use new height
  );
  [(nib.mainWindow) setFrame:newRect display:false animate:true];
}

function popUpContextMenuInWebView(menu, webView, point) {
  const syntheticClick = [NSEvent mouseEventWithType:NSRightMouseDown
    location:flippedPointInView(webView, point.x, point.y)
    modifierFlags:0
    timestamp:(NSProcessInfo.processInfo().systemUptime())
    windowNumber:(webView.window().windowNumber())
    context:null
    eventNumber:9999
    clickCount:1
    pressure:0.0];

  [NSMenu popUpContextMenu:menu withEvent:syntheticClick forView:webView];
}

function possibleSketchLayerNamesFromURL(url, extension) {
  //add to default extensions as at time the dropped layers receive the orginal file extnesion and at times no
  const additionalExtensions = ['png', 'jpeg'];
  if (extension != 'skla'){
    //we get the skla from the file name so no need to add it again
    additionalExtensions.push(extension);
  }
  const possibleNames = [];
  const pathParts = url.split('/');
  const fileName = pathParts[pathParts.length - 1];
  possibleNames.push(fileName); //this will add the name with skla extension

  const fileNameParts = fileName.split('.');
  if (fileNameParts.length > 1) {
    const fileNameWithoutExtension = fileNameParts.slice(0, -1).join('.');

    // Try the extension given by the data or default set of extensions, which might
    // differ from the one in the URL.
    additionalExtensions.forEach(function(addedExtension){
      possibleNames.push(fileNameWithoutExtension + '.' + addedExtension);
    });

    // Try with no extension at all.
    possibleNames.push(fileNameWithoutExtension);
  }

  const possibleNamesCountSoFar = possibleNames.length;
  for (var i = 0; i < possibleNamesCountSoFar; i++) {
    const possibleName = possibleNames[i];
    var decodedName = decodeURIComponent(possibleName);
    decodedName = decodedName.replace(new RegExp(':', 'g'), '-');
    possibleNames.push(decodedName);
  }

  possibleNames.push('Bitmap');

  return possibleNames;
}

function normalizeSelectedSymbols(selectedLayers) {
  const selectedLayersNormalized = NSMutableSet.new();

  $.forEach(selectedLayers, function(layer) {
    const parent = getParentLayer(layer);
    if (parent && parent.class() == 'MSSymbolMaster') {
      // If the direct parent of a selected layer is a symbol master, ignore
      // the layer and pretend the master is selected.
      selectedLayersNormalized.addObject(parent);

    } else {
      // All other layers are added (minus deduplication).
      selectedLayersNormalized.addObject(layer);
    }
  });

  return selectedLayersNormalized.allObjects();
}

function symbolMasterDependenciesForLayers(document, layers) {
  const allSymbolMastersBySize = symbolMastersBySizeInDocument(document);
  const symbolMasterDependenciesBySymbolId = {};
  const symbolMasterDependenciesByLayerId = {};
  var duplicationsFound = false;

  var processLayerTree = function(layer){
    traverseLayerTree(layer, function(layer, isInsideSymbol) {
      // Any symbol found in the layer tree is a dependency.
      if (layer.className() == 'MSSymbolMaster') {
        symbolMasterDependenciesBySymbolId[layer.symbolID()] = layer;
        symbolMasterDependenciesByLayerId[layer.objectID()] = layer.symbolID();

        // Also treat as a dependency any symbol that is
        // the same size as a symbol found inside a symbol
        // (not just inside a layer that the user wants to
        // upload). Layers of the same size nested in a
        // symbol are shown by Sketch as potential overrides
        // so they should be included as dependencies.
        if (isInsideSymbol) {
          const sizeOfSymbol = sizeKeyForLayer(layer);
          const symbolsOfSameSize = allSymbolMastersBySize[sizeOfSymbol];
          if (symbolsOfSameSize) {
            symbolsOfSameSize.forEach(function(symbol) {

              const sameSizeSymbolObjectId = symbol.objectID();
              const sameSizeSymbolSymbolID = symbol.symbolID();

              //symbolID we already found for this layerID
              const foundSymbolIDForLayerID = symbolMasterDependenciesByLayerId[sameSizeSymbolObjectId];

              //if the symbolID was not explored yet add it as a dependency
              //Using this validation we will not add same-size symbols that have different symbolIDs but the same layerID
              if (!foundSymbolIDForLayerID) {
                symbolMasterDependenciesBySymbolId[sameSizeSymbolSymbolID] = symbol;
                symbolMasterDependenciesByLayerId[sameSizeSymbolObjectId] = sameSizeSymbolSymbolID;
                processLayerTree(symbol);
              } else {
                //if layers for some reason have the same layerId and different symbol ids are considered as duplicates
                if (!sameSizeSymbolSymbolID.isEqualToString(foundSymbolIDForLayerID)) {
                  duplicationsFound = true;
                }
              }
            });
          }
        }
      }
    }, logMessage);
  }

  layers.forEach(function(layer) {
    processLayerTree(layer);
  });


  if (duplicationsFound) {
    //if duplication were found report an error
    var allSymbolsMasters = $.map(document.documentData().allSymbols(), function(symbol) {
      return { symbolId: coerceString(symbol.symbolID()), layerId: coerceString(symbol.objectID()), name: coerceString(symbol.name()) };
    });
    logMessage( 'info', { message: 'Same size duplicate elements were found and ignored in uploadLayers',  currentMasterSymbols: allSymbolsMasters });
  }

  // Return just an array of the values.
  return Object.keys(symbolMasterDependenciesBySymbolId).map(function(symbolID) {
    return symbolMasterDependenciesBySymbolId[symbolID];
  });
}



function countLayerArtboards(selectedLayers) {
  const includedArtboardIDs = {};
  const addToSelectionIfNotAlreadyAdded = function(artboard) {
    // Use symbolID falling back to objectID to identify layers.
    const artboardId = artboard.objectID();
    const alreadyIncluded = includedArtboardIDs[artboardId];
    if (!alreadyIncluded) {
      includedArtboardIDs[artboardId] = true;
    }
  };

  const recursivelyLookForArtboard = function(layer) {
    if (layer.class() == 'MSArtboardGroup') {
      addToSelectionIfNotAlreadyAdded(layer);
      return;
    }

    const parent = getParentLayer(layer);
    if (parent) {
      recursivelyLookForArtboard(parent);
    }
  };

  $.forEach(selectedLayers, function(layer) {
    recursivelyLookForArtboard(layer);
  });

  return Object.keys(includedArtboardIDs).length;
}

function findLayerArtboards(selectedLayers) {
  const normalizedSelection = NSMutableArray
    .arrayWithCapacity(selectedLayers.count());

  const includedArtboardIDs = {};
  const addToSelectionIfNotAlreadyAdded = function(artboard) {
    // Use symbolID falling back to objectID to identify layers.
    const artboardId = artboard.objectID();
    const alreadyIncluded = includedArtboardIDs[artboardId];
    if (!alreadyIncluded) {
      normalizedSelection.addObject(artboard);
      includedArtboardIDs[artboardId] = true;
    }
  };

  const recursivelyLookForArtboard = function(layer) {
    if (layer.class() == 'MSArtboardGroup') {
      addToSelectionIfNotAlreadyAdded(layer);
      return;
    }

    const parent = getParentLayer(layer);
    if (parent) {
      recursivelyLookForArtboard(parent);
    }
  };

  $.forEach(selectedLayers, function(layer) {
    recursivelyLookForArtboard(layer);
  });

  return normalizedSelection;
}

// We’ll keep track of symbols, type styles, etc. that have
// been imported so each one is only imported once per
// click or “session.“ The reason this might happen is that each symbol
// can contain other symbols, and so a symbol might be
// refered to more than once.
function resetImportSession() {
  persist.set('IDsImportedThisSession', NSMutableSet.new());
}

// Note: this also adds the ID you are asking about to the
// set of already imported IDs!
function itemHasAlreadyBeenImportedThisSession(key) {
  const alreadyImportedIDs = persist.get('IDsImportedThisSession');
  if (alreadyImportedIDs.containsObject(key)) {
    return true;
  } else {
    alreadyImportedIDs.addObject(key);
    return false;
  }

}

// The returned type of MSDocument.selectedLayers()
// changed between Sketch 41 and 42. This smooths over the
// difference by always returning an NSArray.
function selectedLayersInDocument(document) {
  const selectedLayers = document.selectedLayers();
  if (selectedLayers.class() == 'MSLayerArray') {
    return selectedLayers.containedLayers();
  } else {
    return selectedLayers;
  }
}

function allLibrarySymbolsIndexedBySymbolID(styleData) {

  const imagesByID = {};
  applyToAllImages(styleData, function(image, imageType, sectionId) {
    if (image.metadata && image.metadata.sketchSymbolId) {
      imagesByID[image.metadata.sketchSymbolId] = {
        sectionType: imageType,
        sectionID: sectionId,
        image: image
      };
    }
  });

  //todo: decide what to do here with sketch symbols
  // Add in canonical sketch symbols last because they should “win” the slot
  // for the ID in question.
  (styleData.globalAssets.sketchSymbols || []).forEach(function(symbol) {
    imagesByID[symbol.metadata.sketchSymbolId] = {
      image: symbol
    };
  });

  return imagesByID;
}

function allLibrarySymbolsIndexedBySize(styleData) {
  // todo: we are receiving styleguide here for now, need to discuss what we want to do

  // Note: this does not consider symbols stored as attachments in image
  // sections, e.g. any image with a metadata.sketchSymbolId. It doesn’t seem
  // worth it considering people who use this feature are most likely going to
  // get all those same-sized items in their library via a process that will
  // put them in the canonical sketchSymbols part of the library anyway, which
  // is where we ARE looking.

  const imagesBySize = {};

  (styleData.globalAssets.sketchSymbols || []).forEach(function(symbol) {
    if (symbol.dimensions) {
      const size = symbol.dimensions;
      imagesBySize[size] = imagesBySize[size] || [];
      imagesBySize[size].push(symbol);
    }
  });

  return imagesBySize;
}



function getFileExtension(url) {
  var urlParts = url.split('.');
  return urlParts[urlParts.length - 1].toLowerCase();
}


function getResolvedSharedObjects(image){
  const sharedObjects = (image.metadata && image.metadata.sharedObjects) || {};
  const sharedObjectsV2 =  (image.metadata && image.metadata.sharedObjectsV2Object) || []; //this is already the resolved objects

  var resolvedSharedObjectsMap = {};
  Object.keys(sharedObjects).forEach(function(sharedObjectID){
    if (sharedObjects[sharedObjectID + 'Object']) {
      resolvedSharedObjectsMap[sharedObjectID] = sharedObjects[sharedObjectID + 'Object'];
    }
  });

  sharedObjectsV2.forEach(function(sharedObject){
    resolvedSharedObjectsMap[sharedObject.uuid] = sharedObject;
  });

  return resolvedSharedObjectsMap;
}

function logMessage(level, data){
  postWebUIEvent('onLogMessage', {level: level, data: data});
}

function getKeyName(key) {
  return 'com.invision.dsm.' + key;
}

function getPluginWindow(){

  // Check if the window is already open.
  var app = NSApplication.sharedApplication();
  var mainPluginWindow = $.find(app.windows(), function(window) {
    return window.identifier() == 'com.invision.dsm.mainWindow';
  });
  return mainPluginWindow;
}
